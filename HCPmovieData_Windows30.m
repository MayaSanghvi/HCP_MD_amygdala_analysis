function sp=HCPmovieData_Windows30(movies)
% Left click on bold red BOLD to jump to frame.
% Right click on bold red BOLD red, then click again, to define movie window to play.
% Press any key to pause/unpause playing movie.
% Click on legend to toggle on/off other timecourses
%  (for which numbers are correlations with main timecouse, excluding rest transition periods).

% v11 rewritten to load per subject data, previously summarized per Yeo 17 network plus core MD
% v19 add 2d frame plots
% v22 simplifies use of different parcellations, generated by HCPmovies_ProcessSubjectCIFTI_250524()
% v24 allows saving of video clips
% v25 instead of shifting TRs by 0.5 s, upsample fMRI by factor of 2 and
% interpolate so 1st value is at 0 and last is at nsec
% v26 tidy up a bit
% v28 check GSR; fix time marker; speed up figure generation; allow single
%     ROI; middle click on line to clear TV
% v29 superceded...
% v30... WORK IN PROGRESS
% - Now mean of ROIset is compared to mean of REFset, both with confidence
%       intervals
% - Movie clips are saved with context periods versus period of
%       interest distinguished by border colour
% - ROI data are loaded from ROIdata2025 
% | allow click on 2D plot to jump to nearest timepoint in 1D plot;
% | when selecting a time-window in 1D plot, show its correlation and
%     highlight it in 2D plot
% | reassign cofluctuation peaks to nearest activation peak in same
%     quadrant, or ignore if none
% | add activation plot at selected timepoint
% | allow a button press to to jump to time of cursor? and arrows to
%     advance a frame?
% | add confidence bands to pz?
% | for correlations, add test against noise ceiling, with extra row for
% individual-with-mean correlations
% | keyboard shortcuts to toggle legend/TV/brains
% | across-subject test of pz, controlling FDR
% | for +vely correlated timecourses, t-test of differences, with FDR
% | Output videos seem to only be 720x480?? Would be nice to be able to
% choose this?

%% set these for each computer, ensuring moviedir is local (for speed)
labdir='G:\Duncan-lab\';
spmdir='G:\Imaging-Local\software\spm_cbu_svn\releases\spm12_fil_r7771'; % if hrf needed for convolution
mydatadir=fullfile(labdir,'users','dm01','Ashley','HCPmovieData'); % where the gifti reader is, data preaveraged by network, and semantic labels
% massively faster to read movie from local disk! (put extracted audio files and visual properties here too):
moviedir='C:\HCPmovies\Post_20140821_version'; % my office
%moviedir='C:\Users\dm01\Desktop\HCPmovies'; % seminar room
%moviedir='\\home\RDS_UPD$\dm01\Desktop\Post_20140821_version'; % remote desktop
outdir=mydatadir; % where to save things

cd(fileparts(which(mfilename)))

%% set constants
dbstop if error

if ~nargin, movies=1; end % vector of movies to analyse (plotted in separate windows, and combined for ROI-ROI correlations

convolveMovieMeasures=0; % (necessary if correlating these with BOLD signal, but very slow with HPF)
doCorrelations=0; % adds plots of between ROI correlations, and correlations of movie features with selected ROIs
saveclips=0; % corresponding to top X peaks in each quadrant of prodZ; 1 for video only (slow), 2 for video+activation (very slow, and memory hungry); saved into mydatadir;
saveclipcontext=[4 2]; % the default clip window is from max to min of hrfshift; the two numbers here are how many seconds to prefix and suffix to provide "context"
showlegend=true; % whether to show title and legend on 1D plots
enhancecontrast=0; % attempt to enhance contrast for figures (not saved clips); somewhat slow and may or may not be effective
savefigures=0; % to save tparcellation='MD2020xYeo17'; ROIset='MD'; REFset='DMN-Core';he 1D & 2D figures into mydatadir

% NOTE: function for combining subjects ('func') is now specified below, after data have been loaded

% Currently available cortical parcellations: 'Yeo17', 'Glasser180','Ji12', 'Reza24', 'MDDMparcels', 'MDDM', 'MD2020xYeo17', 'MDDMxJi12', 'subcortical'
%parcellation='Yeo17'; ROIset='DMN-MTL'; REFset='DMN-Core';
%parcellation='Glasser180'; ROIset='8BM'; REFset='v23ab'; doCorrelations=false; % correlation matrices not very practical with 180 ROIs
%parcellation='Ji12'; ROIset='Frontoparietal'; REFset='Default';
%parcellation='Reza24'; ROIset='executive network 2'; REFset='Default';
%parcellation='MDDMparcels'; ROIset='9m'; REFset='8BM';
%parcellation='MDDMparcels'; ROIset='8BM'; REFset='v23ab';
%parcellation='MDDM'; ROIset='MD'; REFset='DM';
%parcellation='Ji12MD'; ROIset='MD'; REFset='Default';
%parcellation='Yeo17MD'; ROIset='MD'; REFset='DMN-Core'; % Uses coreMD2020, and original Yeo
parcellation='MD2020xYeo17'; ROIset='MD'; REFset='DMN-Core'; % Uses coreMD2020, and Yeo with overlap removed *****
%parcellation='MD2020xYeo17'; ROIset='MD'; REFset='MD';
%parcellation={'Yeo17','subcortical'}; ROIset='amygdala'; REFset='DMN-Core';
%parcellation={'Yeo17','MDDMparcels'}; ROIset='DMN-Core'; REFset='8BM';
% parcellation='MDxYeo17'; ROIset='MD'; REFset='DMN-Core'; % Uses FPextMD2020
% parcellation='MDxJi12'; ROIset='MD'; REFset='Default';
% parcellation='netmaskMDDM2020'; ROIset='MD'; REFset='DM';
% parcellation='MDDMxYeo17'; ROIset='MD'; REFset='DMN-Core';
% parcellation='MDDMxJi12'; ROIset='MD'; REFset='Default';
%parcellation={'MD2020xYeo17','subcortical'}; ROIset='amygdala'; REFset='DMN';
%parcellation={'MD2020xYeo17','subcortical'}; ROIset='DMN'; REFset='DMN';
%parcellation='MD2020xYeo17'; ROIset='MD2020_R'; REFset='DMN-Core_R';

parcellation='TianS2'; ROIset='AMY'; REFset='AMY';
%parcellation='subcortical'; ROIset='amygdala'; REFset='hippocampus';
parcellation={'subcortical','TianS2'}; ROIset='AMY-'; REFset='amygdala';

% ROIset is a regular expression for which ROIs (from chosen parcellation(s)) to average and plot peaks for
% This is compared to (average of) region(s) specified by regular expression REFset

if isempty(REFset), REFset=ROIset; end
noref=isequal(ROIset,REFset);

mainplotleftpos=0.20; % fraction of screen width from left to start 1D plot (i.e. space left for TV screen)
nex=10; % number of local maxima (and minima) for which to plot frames (doesn't look nice with <10)
septhresh=10; % minimum separation (s) between selected local extrema within same correlation quadrant
skiprest=true; % whether to skip peaks within rest periods + 10 s following restart
hrfshift=sort([8 6 4],'descend'); % s prior to peak, at which to plot frames
%hrfshift=sort([12 8 6 5 4],'descend');
ctype='pearson'; % for correlating fMRI timecourses with timecourses in legend

screensize=get(0,'ScreenSize');

%% set other paths
CAdir=fullfile(labdir,'users','dm01','ROIs','ColeAnticevicNetPartition'); % where the surface files are
addpath(mydatadir);
addpath(fullfile(labdir,'users','dm01','Ashley','HCPmovieData','cifti-matlab-master'))
addpath(fullfile(labdir,'users','dm01')); % for DockUndock.m
addpath(fullfile(labdir,'users','dm01\MoreTools')); % for axescoord2figurecoord.m, fitplots2.m & violin.m
addpath(fullfile(labdir,'users','dm01\MoreTools\xDF'));
rmpath(spmdir); % needs to be added after all calls to gifti, because for some reason the version of gifti in here always shadows the one that works?

%% close existing figures
fprintf('\nClosing existing figures...'); tic
close all % may run out of memory otherwise
fprintf('Took %.1f secs.',toc)

%% define timings of movie clips
% Finn & Bandettini 2021 has a good description of the movie data.
% Exact times are in HCP_7T_Movie_Clip_Timing.csv.
fname{1}='7T_MOVIE1_CC1_v2.mp4'; % first movie file, total duration 921
timepoints{1} = [20,  264.08,284.08,  505.75,525.75,  713.79,733.79,  797.58,817.58,  901] ; % s, relative to start of each movie
% Movie starts with rest, index 1 is clip onset, then 2 is rest onset, etc.
% Clips are from: "Two Men", "Welcome to Bridgeville", "Pockets", "Inside The Human Body", Montage from "23 Degrees South" & "LXIV"

fname{2}='7T_MOVIE2_HO1_v2.mp4'; % second movie file, total duration 918
timepoints{2} = [20,  246.75,266.75,  525.38,545.38,  794.63,814.58,  898] ; %movie starts with rest, index 1 is clip onset, then 2 is rest onset, clip onset etc...
% Clips are from: "Inception", "The Social Network", "Ocean's Eleven", repeated montage

fname{3}='7T_MOVIE3_CC2_v2.mp4'; % total duration 915
timepoints{3} = [20,  200.58,220.58,  405.13,425.13,  629.25,649.25,  791.79,811.58,  895] ;
% Clips are from: "Off the Shelf", "1212", Mrs. Meyer's Clean Day", "Northwest Passage", repeated montage

fname{4}='7T_MOVIE4_HO2_v2.mp4'; % total duration 901
timepoints{4} = [20,  252.33,272.33,  502.21,522.21,  777.42,797.58,  881] ;
% Clips are from: "Home Alone", "Erin Brokovich", "The Empire Strikes Back", repeated montage

rcols=[0.4 0.7 0.4;  0.7 1.0 0.5;  0.9 0.8 0]; % colours for start of rest, end of rest, and restart

%% load HCP-compatible cortical mesh
R_Isurf = gifti(fullfile(CAdir,'S1200.R.inflated_MSMAll.32k_fs_LR.surf.gii'));
vertices=subsref(R_Isurf,struct('type','.','subs','vertices'));
faces=subsref(R_Isurf,struct('type','.','subs','faces'));
clear R_Isurf

%% load fMRI timecourse per movie, per subject and per ROI
% TR is 1 s.
% I created these files by z-scoring each grayordinate then averaging across
% network grayordinates bilaterally. Prepocessing is 'MSMAll'.
% See HCPmovies_ProcessSubjectCIFTI_250524()
data=cell(1,4);
rest=cell(1,4);
badsubs=cell(1,4);
ROInames={};
issubcortical=[];
vertex_ids=[];
if ~iscell(parcellation)
    parcellation={parcellation};
end
for m=1:numel(movies)
    for p=1:numel(parcellation)
        fprintf('\nLoading %s fMRI data from movie %d...',parcellation{p},movies(m)); tic
        file=fullfile(mydatadir,'ROIdata2025',sprintf('GSR_%s_Movie%d_persub',parcellation{p},movies(m))); % Initial "GSR_" prefix before parcellation name optional (needs to have been created)
        temp=load(file,'ROIs','ROInames','subdirs','badsubs','parcellation','ciftidiminfo'); % 'badsubs' were excluded because MSMAll file was missing for this movie; ROInames are identical across movies
        if p==1
            data{movies(m)}=single(temp.ROIs); % [ROI x time x subject]
            % the following are the same across parcellations:
            badsubs{movies(m)}=temp.badsubs;
            % defining 'rest-restart-period' as 30 s following rest onset (so to 10 s following rest offset)
            nTR=size(data{movies(m)},2);
            rest{movies(m)}=zeros(1,nTR,'uint8');
            reststart=[0 round(timepoints{movies(m)}(2:2:end))];
            for rs=1:numel(reststart)
                rest{movies(m)}((reststart(rs))+1:(reststart(rs)+10))=1; % rest onset
                rest{movies(m)}((reststart(rs))+11:(reststart(rs)+20))=2; % late rest
                rest{movies(m)}((reststart(rs))+21:(reststart(rs)+30))=3; % movie restart
            end
            rest{movies(m)}=rest{movies(m)}(1:nTR); % trim off final "restart"
        else
            data{movies(m)}=cat(1,data{movies(m)},single(temp.ROIs));
        end
        
        if m==1 % set things that are the same across movies
            if strcmp(parcellation{p},'subcortical') % subcortical based on models in cifti
                issubcortical=[issubcortical; ones(size(temp.ROIs,1),1)];
                ROInames=[ROInames; temp.ROInames(:)]; % or temp.parcellation.names(:)
                subcorticalmodels=temp.parcellation;
                ciftidiminfo=temp.ciftidiminfo;
            elseif isfield(temp.parcellation,'S') % subcortical based on grayordinate cdata
                issubcortical=[issubcortical; 2*ones(size(temp.ROIs,1),1)];
                ROInames=[ROInames; temp.ROInames(:)];
                 ciftidiminfo=temp.ciftidiminfo;
                 S=temp.parcellation.S;
            else % cortical
                issubcortical=[issubcortical; zeros(size(temp.ROIs,1),1)];
                ROInames=[ROInames; temp.ROInames(:)]; % based on temp.parcellation.L/R.labels.name(:)
                % next lines are for plotting ROI, which can be done on right hemisphere only
                uids=temp.parcellation.R.labels.key;
                these_vertex_ids=false(numel(uids),numel(temp.parcellation.R.cdata));
                for ni=1:length(uids)
                    these_vertex_ids(ni,:)=temp.parcellation.R.cdata==uids(ni); % network indices, now mapped to rows, per right hemisphere vertex
                end
                vertex_ids=cat(1,vertex_ids,these_vertex_ids);
            end
        end
    end
    fprintf('Took %.1f secs.',toc);
end
clear temp

%%%% remove medial wall, or unlabelled cortex
mw=find(~cellfun(@isempty,regexp(ROInames,'Medial_Wall|(\?\?\?)', 'once')));
ROInames(mw)=[];
issubcortical(mw)=[];
for movie=movies
    data{movie}(mw,:,:)=[];
end
vertex_ids(mw(1:(numel(mw)/2)),:)=[]; % just one hemisphere
%%%%%

nr=numel(ROInames);
fprintf('\n%d subjects. %d ROIs in parcellation.',length(badsubs{movie}),nr)

%% select one/two ROI sets of interest
roiind=find(~cellfun(@isempty,regexp(ROInames,ROIset, 'once')));
if isempty(roiind)
    error('\n%s not found in %s.\n',ROIset,char(join(parcellation,',')))
else %if numel(roiind)>1
    fprintf('\nROI "%s" created from average of: %s',ROIset,char(join(ROInames(roiind),';  ')))
end

refind=find(~cellfun(@isempty,regexp(ROInames,REFset, 'once')));
if isempty(refind)
    error('\n%s not found in %s.\n',REFset,char(join(parcellation,',')))
else %if numel(refind)>1
    fprintf('\nReference "%s" created from average of: %s',REFset,char(join(ROInames(refind),';  ')))
end

%% if subcortical ROI(s), get voxel coordinates for plotting 

% if strcmp(parcellation{p},'subcortical') % subcortical based on models in cifti
%     xyz=cellfun(@(x) ciftidiminfo.models{subcorticalmodels.(x)}.voxlist+1, ROInames(roiind),'uni',0); xyz=[xyz{:}]; % coords of all vox in ROI(s); these seem to be zero-based??
%     if noref
%         xyz_ref=xyz;
%     else
%         xyz_ref=cellfun(@(x) ciftidiminfo.models{subcorticalmodels.(x)}.voxlist+1, ROInames(refind),'uni',0); xyz_ref=[xyz_ref{:}]; % coords of all vox in ref(s); these seem to be zero-based??
%     end
% elseif any(issubcortical(roiind)) % subcortical based on grayordinate cdata
%     allVoxCo=cellfun(@(x) x.voxlist,ciftidiminfo.models(3:end),'uni',0); allVoxCo=[allVoxCo{:}]; % xyz coordinates of all subcortical voxels in cifti
%     ind=find(ismember(S.cdata,S.labels.key(ismember(S.labels.name,ROInames(roiind)))))-ciftidiminfo.models{3}.start+1; % into allVoxCo
%     xyz=allVoxCo(:,ind)+1;
%     if noref
%         xyz_ref=xyz;
%     else
%         ind=find(ismember(S.cdata,S.labels.key(ismember(S.labels.name,ROInames(refind)))))-ciftidiminfo.models{3}.start+1; % into allVoxCo
%         xyz_ref=allVoxCo(:,ind)+1;
%     end
% else
%     xyz=[];
% end

if all(issubcortical(roiind)==1) % main ROI is subcortical based on models in cifti
    xyz=cellfun(@(x) ciftidiminfo.models{subcorticalmodels.(x)}.voxlist+1, ROInames(roiind),'uni',0); xyz=[xyz{:}]; % coords of all vox in ROI(s); these seem to be zero-based??
elseif all(issubcortical(roiind)==2) % main ROI is subcortical based on grayordinate cdata
    allVoxCo=cellfun(@(x) x.voxlist,ciftidiminfo.models(3:end),'uni',0); allVoxCo=[allVoxCo{:}]; % xyz coordinates of all subcortical voxels in cifti
    ind=find(ismember(S.cdata,S.labels.key(ismember(S.labels.name,ROInames(roiind)))))-ciftidiminfo.models{3}.start+1; % into allVoxCo
    xyz=allVoxCo(:,ind)+1;
else
    xyz=[];
end

if noref
    xyz_ref=xyz;
elseif all(issubcortical(refind)==1) % ref ROI is subcortical based on models in cifti
     xyz_ref=cellfun(@(x) ciftidiminfo.models{subcorticalmodels.(x)}.voxlist+1, ROInames(refind),'uni',0); xyz_ref=[xyz_ref{:}]; % coords of all vox in ref(s); these seem to be zero-based??
elseif all(issubcortical(refind)==2) % ref ROI is subcortical based on grayordinate cdata
    allVoxCo=cellfun(@(x) x.voxlist,ciftidiminfo.models(3:end),'uni',0); allVoxCo=[allVoxCo{:}]; % xyz coordinates of all subcortical voxels in cifti
    ind=find(ismember(S.cdata,S.labels.key(ismember(S.labels.name,ROInames(refind)))))-ciftidiminfo.models{3}.start+1; % into allVoxCo
    xyz_ref=allVoxCo(:,ind)+1;
else
    xyz=[];
end

% if main subcortical ROI is bilateral, just plot hemisphere with more coverage
if ~isempty(xyz)
    midline=ciftidiminfo.vol.dims(1)/2;
    if min(xyz(1,:))<midline &&  max(xyz(1,:))>midline
        if sum(xyz(1,:)<midline) > sum(xyz(1,:)>midline)
            xyz(:,xyz(1,:)>midline)=[];
            xyz_ref(:,xyz_ref(1,:)>midline)=[];
        else
            xyz(:,xyz(1,:)<midline)=[];
            xyz_ref(:,xyz_ref(1,:)<midline)=[];
        end
    end
end

%% specify function to preprocess/combine data across subjects
%%% (do it here in case it needs access to data)
addpath(spmdir); % needs to be added after all calls to gifti, because for some reason the version of gifti in here always shadows the one that works?

HPFcp=[]; % Kringelback'23 used 125. 100 common for RS. Probably not really needed|.
% If one entry it's the high-pass filter cutoff period (i.e. remove drifts slower than this).
% If two entries, low-pass then high-pass filter cutoff periods (i.e. remove oscillations faster than the first period and drifts slower than the second).
% e.g. [0 inf] for no filtering (or just leave empty)
% Warning - LPF is slow, will reduce # peaks, and may make peaks less temporally precise and less interpretable

%func=@(x) squeeze(mean(x,3)); % regular mean
%func=@(x) squeeze(var(x,[],3)); % variance
%func=@(x) squeeze( mean(x,3) ./ ( std(x,[],3)/sqrt(size(x,3)) ) ); % t-statistic
%func=@pcapernetwork; % 1st PC is almost identical to mean, which I think is consequence of z-scoring across time per voxel?
%func=@(x) representativesub(x,'most',ROInames); % most representative subject per movie
%func=@(x) representativesub(x,'least',ROInames); % least representative (determined from raw data) followed by GSR
%func=@(x) representativesub(x,'least',ROInames,[],[],true); % least representative (determined from raw data) followed by GSR
%func=@(x) representativesub(x,'least',ROInames,data,badsubs); % most/least representative subject across all movies
%func=@(x) csrMeanOrVar(x,'mean',1,0); % do global signal regression per subject (using parcellated data) before averaging (no HPF)
%func=@(x) csrMeanOrVar(x,'mean',2,0); % do global signal subtraction per subject (using parcellated data) before averaging (no HPF)
func=@(x) csrMeanOrVar(x,'mean',0,0); % just averaging (no GSR or HPF)
%func=@(x) csrMeanOrVar(x,'var',1,0);
%func=@(x) csrMeanOrVar(x,'t',1,0);
%func=@(x) csrMeanOrVar(x,'mean',0,HPFcp); % apply high-pass filter per subject (with cutoff period specified in s) before averaging (no GSR)
%HPFcp=450; func=@(x) csrMeanOrVar(x,'mean',1,HPFcp); % both
%func=@(x) cna(x,ROInames,'global'); % 'confound nulling average' - I made this up... can we find a non-negative weighting of subjects that makes a confound signal (e.g. global) as close to zero as possible over time?
% 3rd input could be 'global', 'other', or a regular expression into ROInames
%func=@(x) cna(x,ROInames,'global',data,badsubs); % across all movies
%func=@(x) cna(x,ROInames,'other');


%% plot correlation matrices for all ROI pairs
% (for rest/movie and per subject or on average subject)
% sort ROIs by their correlation with target ROIset
% (If multiple ROIs areselected, they are kept separate at this stage, except for ordering based correlation with their mean)

if doCorrelations
    
    fig=998;
    figure(fig); clf(fig);
    set(fig,'name','Between-network correlation matrices','color','w','WindowState','Maximized'); % ,'WindowStyle','modal'
    drawnow;
    pos=fitplots2([2 3],'',44);
    persubtxt={'Correlations of mean subject','Mean of per subject correlations'};
    reordering=[];
    restrestart=[2 1 0];
    for persub=0:1
        for rr=1:numel(restrestart)
            
            C=nan(nr,nr,numel(movies));
            P=nan(nr,nr,numel(movies));
            Z=nan(nr,nr,numel(movies));
            V=nan(nr,nr,numel(movies));
            mi=0;
            for movie=movies
                mi=mi+1;
                if restrestart(rr)==0
                    mask=~rest{movie}; % just use movie periods
                    conditiontxt='Movie';
                elseif restrestart(rr)==1
                    mask=rest{movie}>0; % just use rest/restart periods
                    conditiontxt='Rest/Restart';
                elseif restrestart(rr)==2
                    mask=true(size(rest{movie})); % use whole timecourse
                    conditiontxt='All';
                end
                
                try
                    [as, ~, ss]=feval(func,data{movie}); % combine subjects, to give [networks x time]; also return processed single subject data
                catch
                    as=feval(func,data{movie}); % combine subjects, to give [networks x time]
                    ss=data{movie}; % unprocessed single subject data
                end
                
                if persub
                    %                     % Some subjects have missing MSMall data for some movies, so match up subjects and exclude any with partial data
                    %                     temp=nan(size(alldata{m},1),size(alldata{m},2),numel(badsubs{1}));
                    %                     temp(:,:,~badsubs{m})=alldata{m};
                    %                     alldata{m}=temp;
                    %                     drop=squeeze(any(isnan(alldata(1,:,:)),2));
                    %                     alldata(:,:,drop)=[];
                    
                    nsub=size(ss,3);
                    temp=nan(nr,nr,nsub);
                    for s=1:nsub
                        xy=ss(:,mask,s);
                        temp(:,:,s)=corr(xy');
                    end
                    C(:,:,mi)=mean(temp,3);
                    [~, P(:,:,mi),~,Stat]=ttest(temp,0,'dim',3); % calculated per movie because nsub differs by movie
                    P(logical(eye(length(P))))=1;
                    Z(:,:,mi)=Stat.tstat; % for n this large, t~z
                    V(:,:,mi)=(Stat.sd/sqrt(nsub)).^2; % se^2 ie. variance of sampling distribution of mean
                    clear temp
                else
                    xy=as(:,mask);
                    C(:,:,mi)=corr(xy');
                    %[VarRho,Stat]=xDF(xy,length(xy),'taper','tukey',sqrt(length(xy))); %'truncate','adaptive' most accurate; 'taper','shrink' suggested for long BOLD time series, but doesn't work?
                    %[VarRho,Stat]=xDF(xy,length(xy),'truncate','adaptive');
                    [V(:,:,mi),Stat]=xDF(as,length(as));
                    % see Afyouni, 2018; Note: p values are NOT corrected
                    % for multiple comparisons, but ARE corrected for
                    % tempoaral autocorrelation. Check with
                    % 2*(1-normcdf(Stat.z(2)));
                    % THESE ARE NOT APPROPRIATE FOR TEMPORALLY
                    % MASKED/SPLICED DATA, SO ARE CALCULATED ON THE FULL
                    % DATA. RECALCULATE Z AND P USING FULL-DATA-V AND
                    % REDUCED-DATA-R BUT BE AWARE THIS IS AN APPROXIMATION
                    rf      = atanh(C(:,:,mi));
                    sf      = V(:,:,mi)./((1-C(:,:,mi).^2).^2);
                    rzf     = rf./sqrt(sf);
                    rzf(1:length(C)+1:end) = 0;
                    Z(:,:,mi)=rzf;
                    f_pval  = 2 .* normcdf(-abs(rzf));  %both tails
                    f_pval(1:length(C)+1:end) = 0;
                    P(:,:,mi)=f_pval;
                end
            end % always average over movies at end
            %C=mean(C,3);
            W=1./V; % weights for weighted mean over movies (Hedges et al 1992; Hedges & Olkin 1985)
            se=sqrt(1./sum(W,3)); % se of weighted mean
            W=W./repmat(sum(W,3),1,1,size(W,3));
            C=sum(W.*C,3); % weighted mean
            
            % sort ROIs by their correlation (of subj mean) with target ROIset
            atr=mean(C(roiind,:),1); % average across target regions
            reordering=[]; % comment this line to keep same ordering across plots
            if isempty(reordering)
                [~, reordering]=sort(atr,'descend');
            end
            C=C(reordering,reordering);
            P=P(reordering,reordering,:);
            Z=Z(reordering,reordering,:);
            se=se(reordering,reordering,:);
            snames=ROInames(reordering);
            
            ax=axes('position',pos{persub+1,rr}); cla
            if size(P,3)>1
                %P=max(P,[],3); % probability of being significant in ALL movies
                %P= 1 - chi2cdf( -2.*sum(log(P),3) , 2*size(P,3) ); % probability of being significant in ANY movie (Fisher's method, assuming independence)
                %P=harmmean(P,3);
                [Normore, Puormore]= ConjunctionAnalysis(permute(P,[3,1,2]),struct('dependency','Simes','datatype','p','FDR',[])); P=squeeze(Puormore(2,:,:)); % significant in at least half of movies, allowing for dependence
                % Any way of combining P values could be problematic if using them to get CI's?
                % what about combining (mean) z stat?
                %Z=mean(Z,3);
                %Z=sum(Z,3)/sqrt(size(Z,3)); % Stouffer's method
            end
            P(1:length(C)+1:end) = nan;
            [sig,~,~,~]=fdr_bh(P); % control FDR (across connections)
            H=PlotCMat(C,regexprep(snames,'.*\s',''),'Correlation (r)',{sig,'.','color','k'});
            H.C.FontWeight='bold'; H.C.FontSize=12;
            tobold=unique([1; find(~cellfun(@isempty,regexp(snames,REFset, 'once')))]);
            [H.T(tobold).FontWeight]=deal('bold'); delete(H.C); % options for nicer printing
            caxis([-1 1]); cmap=colorcet('D1'); colormap(cmap)
            tit=sprintf('%s (Movies %s); %s',persubtxt{persub+1},mat2str(movies),conditiontxt);
            % title gets moved around with camera, so use text to fix in axis coordinates
            text(0,0,tit,'interpreter','none','HorizontalAlignment','center');
            
            % add bars for correlation of target with others
            set(ax,'CameraViewAngleMode','Manual')
            set(ax,'CameraPositionMode','Manual')
            set(ax,'CameraTargetMode','Manual')
            set(ax,'CameraUpVectorMode','Manual')
            nc=length(C);
            % the tilted axis, with units in sqaures, makes it very hard to
            % add a bar graph; this can be done more easily with lines:
            stretch=4;
            zeropos=abs(min([C(1,2:end) 0]))*stretch;
            x0=(2:nc)+0.5 -(H.mt + zeropos);
            y0=(2:nc)+0.5 +(H.mt + zeropos);
            x1=x0-stretch*C(1,2:end);
            y1=y0+stretch*C(1,2:end);
            L=line([x0; x1],[y0; y1],'linewidth',7);
            tC=C.*(triu(C,1)./triu(C,1)); % triangular without diagonal
            tC(end,1:2)=[-1 1]*max(abs(tC(:))); % trick to ensure symmetry around zero when rescaling
            indcol=ceil(1+(tC-min(tC(:)))/(max(tC(:))-min(tC(:)))*(length(cmap)-1) ); % rescale to match symmetric colour map
            for l=1:numel(L)
                L(l).Color=squeeze(ind2rgb(indcol(1,1+l),cmap));
            end
            text(x1(1)-1,y1(1)-1,sprintf('%.2f',C(1,2)),'interpreter','none','HorizontalAlignment','center');
            H.LT(2).XData(2)=x1(1)-0.5; H.LT(2).YData(2)=y1(1)-0.5; % add axis
            % add dots on axis to mark significance, FDR corrected for this row
            [sig2,~,~,~]=fdr_bh(P(1,2:end));
            plot(x0(sig2==1),y0(sig2==1),'ko','MarkerFaceColor','k','MarkerEdgeColor','none');
            
            % add zero line
            x0=2 -(H.mt+zeropos);
            y0=2 +(H.mt+zeropos);
            x1=1+nc -(H.mt+zeropos);
            y1=1+nc +(H.mt+zeropos);
            line([x0; x1],[y0; y1],'linewidth',1,'color','k');
            
            % add CIs (calculated from SE, Zs or Ps)
            %z=-0.862+sqrt(0.743-2.404*log(P(1,2:end))); % Altman, 2011; (Ps should be 2-sided; could alternatively use FDR adjusted p)
            %z=Z(1,2:end);
            %se=abs(C(1,2:end))./abs(z);
            se=se(1,2:end);
            ci95=1.96*[-1; 1]*se + [1;1]*C(1,2:end);
            x0=(2:nc)+0.5 -(H.mt + zeropos + ci95(1,:)*stretch);
            y0=(2:nc)+0.5 +(H.mt + zeropos + ci95(1,:)*stretch);
            x1=(2:nc)+0.5 -(H.mt + zeropos + ci95(2,:)*stretch);
            y1=(2:nc)+0.5 +(H.mt + zeropos + ci95(2,:)*stretch);
            line([x0; x1],[y0; y1],'linewidth',1,'color','k');
            text(x1(tobold(2)-1)-0.5, y1(tobold(2)-1)+0.5, sprintf('%.2f',C(1,tobold(2))),'interpreter','none','HorizontalAlignment','left');
            
            drawnow
            
        end % movie periods then rest periods
    end % for average sub, then average of subs
    set(findall(998,'-property','FontSize'),'FontSize',12)
    
end % do correlation?


%% load the movies
obj=cell(1,4);
movieName=cell(1,4);
TS=cell(1,4); % time stamps for movie frames (s)
mf=cell(1,4); % movie features (per frame; e.g. visual, auditory, semantic)

warning('off','MATLAB:subscripting:noSubscriptsSpecified')

for movie=movies
    fprintf('\nOpening movie %d...',movie); tic
    movieName{movie} = fullfile(moviedir,fname{movie});
    
    obj{movie} = VideoReader(movieName{movie}); %#ok<*TNMLP>
    % numberOfFrames =obj.NumberOfFrames; % if this is queried, currenttime can't be set.
    % For movie1, ~22097 frames @ 24 fps = 920.7 s ~=15 mins; 1024x720; RGB24
    
    % get timestamps per frame
    % approximate but accurate enough to construct this from duration and framerate
    timestamps=(0:(1/obj{movie}.FrameRate):obj{movie}.Duration)';
    timestamps(end)=[];
    TS{movie}=single(timestamps);
    clear timestamps
    
    fprintf('Took %.1f secs.',toc)
end % next movie
% all are at 24 fps, despite what it says in HCP_7T_Movie_info.csv (23-30 fps)

%% get some visual properties of the movie frames

for movie=movies
    fprintf('\nLoading visual properties of movie %d...',movie); tic
    
    % get a few low-level visual measures of luminance, change etc.
    [~,nam] = fileparts(movieName{movie});
    visfile = fullfile(moviedir,[nam,'_VisualProperties.mat']);
    if exist(visfile,'file')
        load(visfile,'visualProperties');
    else
        % calculating these takes ~45 minutes per movie
        ii = 1;
        clear visualProperties
        fprintf('\nMeasuring low-level visual properties...')
        while hasFrame(obj{movie})
            thisframe=readFrame(obj{movie});
            if ii<2, lastframe=thisframe; end
            if ii<3, lastframe2=lastframe; end
            
            visualProperties.luminance(ii)=mean(thisframe(:));
            lab=rgb2lab(thisframe);
            visualProperties.variance(ii)=var(reshape(lab(:,:,1),1,[]));
            visualProperties.changeRMS(ii)=sqrt(mean((thisframe(:)-lastframe(:)).^2));
            visualProperties.changeCor(ii)=1-corr(double(thisframe(:)),double(lastframe2(:))); % see Cutting 2012
            
            lastframe2=lastframe;
            lastframe=thisframe;
            ii = ii + 1;
        end
        visualProperties.changeCor(isnan(visualProperties.changeCor))=0;
        
        % RESET:
        obj{movie} = VideoReader(movieName{movie});
        
        % Correlation distance seems better change measure for detecting cuts?
        % (But doesn't always detect 'rest' transitions if these are to a flat screen.)
        % A cut should be a strong change, but ALSO sharp: relatively stable either side;
        % (a major movement might be a strongish change but should last for longer)
        % so could also look for large 2nd deriviative?
        changeCor2z=zscore(abs([0 diff(1-[visualProperties.changeCor],2) 0]));
        visualProperties.cuts=changeCor2z>3 & visualProperties.changeCor>0.5;
        
        save(visfile,'visualProperties')
        
    end % load or calculate
    mf{movie}=visualProperties;
    clear visualProperties
    
    fprintf('Took %.1f secs.',toc)
end % next movie


%% get static visual sementic (wordnet) features from Gallant lab
fprintf('\nReading Gallant lab semantic features...'); tic

semanticlabelfile=fullfile(mydatadir,'movie_resources','WordNetFeatures.hdf5');
% synsets=h5read(semanticlabelfile,'/synsets');
%
% synsetmat=cell(1,length(movies));
% for movie=movies
%     synsetmat{movie}=h5read(semanticlabelfile,['/' fname{movie}(4:13)]);
% end

% visual semantic features are described in: HCP.7T.Movie.FeatureSpaces.pdf.
% This states that text should be labeled as text.n.01, subtitle.n.01,
% title.n.08, credits.n.01, yet only title is in the synset list??
% Do the others get converted to the hypernym e.g. "matter.n.06"?
% If "entailed" superordinate categories have been added, then the sum
% measures approximate 'specificity' more than 'richness'. Since this is
% unclear, score using originally labelled .txt files?
for movie=movies
    txtfile=regexprep(semanticlabelfile,'WordNetFeatures.hdf5',sprintf('WordNet_%s.txt',fname{movie}(4:13)));
    fid=fopen(txtfile);
    C=textscan(fid,'%s'); C=C{1};
    for TR=1:length(C)
        labels=regexp(C{TR},'\w+\.(n|v)\.\d\d','match');
        if isempty(labels), labels={'nothing'}; end
        mf{movie}.VisNoun(TR)=length(regexp([labels{:}],'\.n\.'));
        mf{movie}.VisVerb(TR)=length(regexp([labels{:}],'\.v\.'));
        mf{movie}.LabText(TR)=double(~isempty(regexp([labels{:}],'(text|subtitle|title|credits|sign.n.02|number.n.02|numeral.n.01|caption.n.03)', 'once')));
        % the first 4 were in instructions; I added the rest
        if TR>1
            %sf{movie}.StableVisSem(TR)=sum(ismember(labels, previouslabels));
            mf{movie}.VisSemInc(TR)=sum(~ismember(labels, previouslabels));
            mf{movie}.VisSemDec(TR)=sum(~ismember(previouslabels,labels));
            mf{movie}.VisSemFlux(TR)=mf{movie}.VisSemInc(TR) + mf{movie}.VisSemDec(TR);
        end
        previouslabels=labels;
    end
    fclose(fid);
end
clear C labels
% Also problematic is that this seems to be purely visual labelling. E.g.
% if the narrator is not visible then there may be no labels for speech, or
% narration etc. Similarly there will be no labels for music or other
% sounds. Also, we don't know whether people rated scenes sequentially or
% in context of rest of movie.
fprintf('Took %.1f secs.',toc)

%% get motion energy features
fprintf('\nReading Gallant lab motion energy features'); tic
motionenergyfile=fullfile(mydatadir,'movie_resources','MotionEnergyFeatures.hdf5');
for movie=movies
    [~, nam,~]=fileparts(movieName{movie});
    MEfile=fullfile(moviedir,[nam '_ME.mat']);
    if exist(MEfile,'file')
        load(MEfile,'ME');
    else
        ME=h5read(motionenergyfile,['/' fname{movie}(4:13)]);
        ME=mean(ME);
        save(MEfile,'ME');
    end
    mf{movie}.ME=ME;
    clear ME
    fprintf('.')
end
fprintf('Took %.1f secs.',toc)

%% load audio
audios=cell(1,4); % audio data
ts=cell(1,4); % audio time points
soundtables=cell(1,4); % classified sounds
Fs_new = 16000; % downsample to this, to speed up loading time
for movie=movies
    fprintf('\nLoading audio from movie %d...',movie); tic
    [~, nam,~]=fileparts(movieName{movie});
    audiofile=fullfile(moviedir,[nam '_audio.mat']);
    if exist(audiofile,'file')
        temp=load(audiofile,'audio','t');
        audios{movie}=temp.audio;
        ts{movie}=temp.t;
        clear temp
    else
        [a, Fs] = audioread(movieName{movie});
        a=sum(a,2); % combine channels
        
        % downsample
        [Numer, Denom] = rat(Fs_new/Fs);
        a = single(resample(a, Numer, Denom));
        
        audio=a; % (a-min(a))/range(a); % scale from 0-1
        t = 0:(1/Fs_new):obj{movie}.Duration; % time range for audio data
        t = single(t(1:end-1));
        
        save(audiofile,'audio','t');
        
        audios{movie}=audio;
        ts{movie}=t;
    end
    
    % load preprocessed audio features
    soundsfile=fullfile(moviedir,[nam '_classifiedSounds.mat']);
    if exist(soundsfile,'file')
        load(soundsfile,'soundTable','sounds');
        soundtables{movie}=soundTable;
    else
        soundtables{movie}={};
    end
    
    fprintf('Took %.1f secs.',toc);
end

%% to save video clips
% to include audio, must be .avi (in which "quality" & "CompressionFactor parameters are ignored)
if saveclips>0
    clipdir=fullfile(outdir,'savedClips'); % was moviedir, but this might be local with limited space (clips saved with activation are huge)
    if ~exist(clipdir,'dir'), mkdir(clipdir); end
    
    timestr=sprintf('%d-%d-%d-%dsPrePeak',saveclipcontext(1)+max(hrfshift),max(hrfshift),min(hrfshift),min(hrfshift)-saveclipcontext(2));
    clipdir=fullfile(clipdir,sprintf('Peaks_of_%s_%s_vs_%s_%s',char(join(parcellation,'&')),ROIset,REFset,timestr));
    if ~exist(clipdir,'dir'), mkdir(clipdir); end
    %     videoFWriter = vision.VideoFileWriter(fullfile(clipdir,'test4.avi'),'FileFormat','AVI',...
    %         'AudioInputPort',true,'FrameRate',obj{m}.FrameRate,...
    %         'AudioCompressor','None (uncompressed)','VideoCompressor','DV Video Encoder'); % options 'None (uncompressed)', 'DV Video Encoder', or 'MJPEG Compressor'
    % for 10 s clip with no compression, size is 0.5GB; takes 4.5 s; opens okay in mediaplayer and vlcplayer
    % DV Video Encoder works for video but not audio; size is 28MB; takes 2.6 s; also opens fine
    % MJPEG Compressor takes 6.6 s; size is 100MB
    
    FrameRate=obj{movie}.FrameRate;
    aframelen=round(16000/FrameRate); % audio samples per video frame
end

%% resample all movie features to be per frame
% (audio is higher resolution; semantic and motion energy features from Gallant lab are per TR)

Fs_toconv = 24;
[Numer, Denom] = rat(Fs_toconv/Fs_new);

for movie=movies
    mf{movie}.AudioVol= resample(double(abs(audios{movie})), Numer, Denom);
    
    mfnames=fieldnames(mf{movie})';
    for fn=1:length(mfnames)
        if numel(mf{movie}.(mfnames{fn})) < numel(TS{movie})
            mf{movie}.(mfnames{fn})=resample(mf{movie}.(mfnames{fn}),24,1);
        end
    end
    
end

%%  Convolve movie measures with HRF
if convolveMovieMeasures
    fprintf('\nConvolving movie measures with HRF...'); tic
    hrf=spm_hrf(1/24); % resolution of frame rate
    
    for movie=movies
        
        for fn=1:length(mfnames)
            mf{movie}.(mfnames{fn})=conv(mf{movie}.(mfnames{fn}),hrf);
            mf{movie}.(mfnames{fn})=mf{movie}.(mfnames{fn})(1:length(TS{movie}));
        end
        
        fprintf('.')
    end
    
    clear ts
    
    fprintf('Took %.1f secs.',toc);
end

%% load example T1
%ssV=spm_vol(fullfile(spmdir,'canonical','single_subj_T1.nii'));
%ssY=spm_read_vols(ssV);
% ciftidiminfo.vol.sform seems to be shifted by 2mm wrt ssV.mat?

fn=fullfile(mydatadir,'..','..','HumanMaze','HCPanalysis','MRI_data','CBU230063','MNINonLinear','xfms','IntensityModulatedT1.nii');
ssV=spm_vol(fn);
ssY=single(spm_read_vols(ssV));

%% if BOLD data are HPFed, do same to movie measures
if convolveMovieMeasures && ~isempty(HPFcp) && ~isnan(HPFcp) && HPFcp>0
    % currently VERY slow; better to use different method, or do it at the
    % resolution of BOLD?
    
    TR=1/24; % resolution of convolved measures all at video frame rate
    fprintf('\nApplying %d s HPF to movie measures',HPFcp); tic
    for movie=movies
        
        % get Discrete Cosine Transform basis set to implement bandpass filter
        nt=numel(TS{movie});
        K   = spm_dctmtx(nt,nt);
        nHP = fix(2*(nt*TR)/HPFcp + 1); % High pass cutoff period specified in s
        nLP = fix(2*(nt*TR)/0 + 1); % Actually don't remove any high frequencies
        K   = K(:,[1:nHP nLP:nt]); % include initial constant term
        
        R  = eye(length(K)) - K*pinv(K); % residual forming matrix
        
        for fn=1:length(mfnames)
            mf{movie}.(mfnames{fn})=R*mf{movie}.(mfnames{fn})(:);
        end
        fprintf('.');
    end
    clear TR nt K nHP nLP R
end

%% prepare figure to plot correlations of movie features with BOLD timecourses
if doCorrelations
    fig=997;
    figure(fig); clf(fig);
    set(fig,'name','Correlations with movie features','color','w','WindowStyle','normal','WindowState','Maximized');
    pos=fitplots2([4 nn],'',4);
end

%% for calculating critical values of product
zs=linspace(-20,20,5000); % +-12 seems fine for independent normals; +-20 seems better for correlations up to ~0.7, to ensure tails become vanishingly small
% fzi=@(zs) besselk(0,abs(zs)) /pi; % Distribution of product of independent Normal samples
% cdfi=nan(size(zs));
% for i=1:numel(zs)
%     cdfi(i)=integral(fzi,-inf,zs(i)); % cumulative distribution function
% end
% criti=zs([find(cdfi>=0.025,1) find(cdfi<=0.975,1,'last')]); % critical values of the product, beyond which p<0.05, two-tailed
criti=[-2.1811  2.1811]; % precalculated with zs=linspace(-20,20,20000);

%% plot the frames corresponding to the local maxima and minima per timecourse
ns=length(hrfshift);

sp=gobjects(4,1); % movies x ROIs (latter now just mean of ROIset)
cols=winter(length(mfnames));

%rest2=cellfun(@(x) uint8([1 interp1((1:nTR)-0.5,double(x),0.5:0.5:(nTR-0.5),'nearest') 2]),rest,'uni',0);
rest2=rest; % will be upsampled below

for movie=movies
    fprintf('\nFigures for movie %d:',movie)
    
    % At this stage, all ROIs in dataset are included, separately.
    % Now put mean of ROIset at beginning, followed by mean of REFset (if
    % different), then any other ROIs not included in either.
    orig_roiind=roiind; % retain these for indexing into vertex list
    orig_refind=refind; % retain these for indexing into vertex list
    others=setdiff(1:nr,[roiind; refind]);
    if noref
        data{movie}=cat(1, mean(data{movie}(roiind,:,:),1), data{movie}(others,:,:));
        ROInames=[ROIset; ROInames(others)];
        issubcortical=[mean(issubcortical(roiind)); issubcortical(others)];
        roiind=1;
        refind=1;
    else
        data{movie}=cat(1, mean(data{movie}(roiind,:,:),1), mean(data{movie}(refind,:,:),1), data{movie}(others,:,:));
        ROInames=[ROIset; REFset; ROInames(others)];
        issubcortical=[mean(issubcortical(roiind)); mean(issubcortical(refind)); issubcortical(others)];
        roiind=1;
        refind=2;
    end
    
    % now combine subjects
    try
        [toplot, sem, ss]=feval(func,data{movie}); % combine subjects, to give [networks x time]; also return processed single subject data
    catch
        toplot=feval(func,data{movie}); % combine subjects, to give [networks x time]
        sem=[];
        ss=[];
    end
    
    nTR=size(toplot,2);
    
    %gs=mean(data{movie}(contains(ROInames,'17'),:,:));  % ... global signal (averaged across Yeo17 networks, excluding Medial Wall and Core MD)
    gs=mean(data{movie});
    
    if isequal(func2str(func),'@(x)squeeze(mean(x,3))') % also get errorbars
        sem=feval(@(x)squeeze(std(x,[],3)),data{movie})./sqrt(size(data{movie},3));
        ss=data{movie};
    end
    
    % assume BOLD samples are at 0.5, 1.5, ... (n-0.5) s
    % and resample to be at 0, 0.5, 1.0, 1.5, ... n s
    toplot=interp1( (1:nTR)-0.5,toplot',0:0.5:nTR,'pchip')';
    if ~isempty(sem)
        sem=interp1((1:nTR)-0.5,sem',   0:0.5:nTR,'pchip')';
    end
    nTR2=nTR*2+1;
    rest2{movie}=uint8([1 interp1((1:nTR)-0.5,double(rest{movie}),0.5:0.5:(nTR-0.5),'nearest') 2]);
    % this should make cofluctuation peak timing a bit more precise.
    % Now 1st BOLD sample is at t=0 s
    %x=(1:nTR)-0.5; % x will be time axis where zero is at start of movie; 1 value per true TR, assuming 1st TR comes 0.5 s into movie
    x2=linspace(0,nTR,nTR2); % x2 will be time axis for upsampled BOLD
    
    try
        gs=feval(func,gs);
        fprintf('\nApplied %s to global signal',func2str(func))
    catch % this may not make sense, depending on func
        %gs=mean(toplot(contains(ROInames,'17'),:,:));
        gs=mean(toplot);
        fprintf('\nCalculated global signal of %s',func2str(func))
    end
    if numel(gs)==nTR
        gs=interp1((1:nTR)-0.5,gs',0:0.5:nTR,'pchip')';
    end
    
    % plot per-subject correlations of movie features with BOLD timecourses
    if ~isempty(ss) && convolveMovieMeasures && doCorrelations
        figure(997)
        barcol=[0 0.5 1];
        
        subplot('position',pos{movie,1});
        title(sprintf('%s, movie %d',ROInames{1},movie),'interpreter','none') % 1 is mean of ROIset; could plot others
        b=squeeze(ss(1,:,:)); % BOLD data, time x subj;  % 1 is mean of ROIset; could plot others
        bm=mean(b,2); % mean across subjects
        bmloo=nan(size(b)); % for leave-one-out mean across subjects
        nsub=size(b,2);
        for s=1:nsub
            bmloo(:,s)=mean(b(:,setdiff(1:nsub,s)),2);
        end
        mcm=mean(corr(b,bm ,'type',ctype)); % mean subject correlation with subject-mean gives upper bound of noise ceiling
        mcloom=mean(diag(corr(b,bmloo ,'type',ctype))); % mean correlation with leave-one-out-mean gives lower bound of noise ceiling
        clear bmloo
        
        h0(1)=patch([0 0 numel(mfnames)+1 numel(mfnames)+1],[mcloom mcm mcm mcloom],sqrt(barcol),'edgecolor','none');hold on;
        h0(2)=patch([0 0 numel(mfnames)+1 numel(mfnames)+1],-[mcloom mcm mcm mcloom],sqrt(barcol),'edgecolor','none');
        
        mc=nan(1,length(mfnames)); % mean (of per-subject) correlations
        cm=nan(1,length(mfnames)); % correlation of mean (across subjects)
        half95ci=nan(1,length(mfnames)); % half width of 95% CI of mc
        for fn=1:length(mfnames)
            temp=resample(mf{movie}.(mfnames{fn})(:),1,24);
            c=corr( temp(~rest{movie}), b(~rest{movie},:) ,'type',ctype);
            mc(fn)=mean(c);
            cm(fn)=corr( temp(~rest{movie}), mean(b(~rest{movie},:),2) ,'type',ctype);
            [~,~,ci]=ttest(c);
            half95ci(fn)=range(ci)/2;
        end
        clear b
        h1=bar(mc); h1.EdgeColor='none'; h1.FaceColor=barcol;
        h2=errorbar(mc,half95ci,'ok'); h2.Marker='none';
        h3=plot(cm,'o');
        set(gca,'XTick',1:numel(mfnames), 'XTickLabel',mfnames,'XTickLabelRotation',45);
        axis tight
        if n==1
            ylabel('r');
            legend([h1 h0(1) h3],{sprintf('mean %s corr',ctype),'noise ceiling',sprintf('%s corr of mean',ctype)})
        end
    end 
    
    % product of zscored time-courses (whose mean gives ppmc)
    % (could consider product of movie-period-standardised time-courses??
    za=toplot(1,:);      za=zscore(za); % mm=mean(za(~rest{movie})); mv=std(za(~rest{movie})); za=(za-mm)./mv;
    zb=toplot(refind,:); zb=zscore(zb); % mm=mean(zb(~rest{movie})); mv=std(zb(~rest{movie})); zb=(zb-mm)./mv;
    % note: will average across multiple refinds
    pz=za.*zb;
    
    % calculate iso-probability contours at 95% critical values for product of correlated normals
    if ~noref
        fprintf('\nCalculating probability threshold for product of correlated normals...'); qtic=tic;
        r=mean(pz); % correlation coeffcient (based on full timecourse)
        fzc=@(zs) 1/(pi*sqrt(1-r^2)) * (min(realmax,exp((r*zs)/(1-r^2))) .* besselk(0,abs(zs)/(1-r^2)) ); % Distribution of product of correlated Normal samples (Nadarajaha and Pog�ny, 2015); multiplying 2nd terms first avoids inf/nan
        cdfc=nan(size(zs));
        for i=1:numel(zs)
            cdfc(i)=integral(fzc,-100,zs(i)); % cumulative distribution function (-inf can give nan if r<0; -100 is tiny enough)
        end
        critc=zs([find(cdfc>=0.025,1) find(cdfc<=0.975,1,'last')]); % critical values of the product, beyond which p<0.05, two-tailed
        fprintf('Took %.1f secs.',toc(qtic));
    end
    
    % find all local driving extrema of prod(z)
    if noref || r>0 % identify only peaks of product, but split into ++ and --
        maxx=find(islocalmax(pz) & za>0 & zb>0); % this is the indext into the fMRI vector i.e. 1 is the 1st TR, at time 0 of the movie
        maxy=pz(maxx); % the height of the plotted 1D curve, for annotating
        minx=find(islocalmax(pz) & za<0 & zb<0);
        miny=pz(minx);
    else % identify only troughs of product, but split into +- and -+
        maxx=find(islocalmin(pz) & za>0 & zb<0);
        maxy=pz(maxx);
        minx=find(islocalmin(pz) & za<0 & zb>0);
        miny=pz(minx);
    end
    %extrema=union(maxx, minx);
    
    % find nex local driving extrema in 1st quadrant:
    if ~noref && r<=0 % for negative correlations
        [~, ind]=sort(maxy,'ascend'); % sort driving +- troughs of product, from deepest to shallowest
    else % for positive correlations
        [~, ind]=sort(maxy,'descend'); % sort driving ++ peaks of product, from highest to lowest
    end
    selectedi=[]; count=1;
    while length(selectedi)<nex % take top nex, skipping any that are during "rest", near very start, or too close together
        if skiprest && rest2{movie}(maxx(ind(count)))>0
            count=count+1; continue; % skip if in 30 s following rest onset
        end
        if count>numel(maxx), error('Error selecting local maxima'); end
        if x2(maxx(ind(count)))>min(hrfshift) && ~any(abs(maxx(selectedi)-maxx(ind(count)))<(2*septhresh))
            selectedi(end+1)=ind(count);
        end
        count=count+1; 
    end
    maxy=maxy(selectedi);
    maxx=maxx(selectedi);
    maxi=tiedrank(maxx); % get their chronological order
    
    % find nex local driving extreme in opposite quadrant:
    if noref || r>0 % for positive correlations
        [~, ind]=sort(miny,'descend'); % sort driving -- peaks of product, from highest to lowest
    else % for negative correlations
        [~, ind]=sort(miny,'ascend'); % sort driving -+ troughs of product, from deepest to shallowest
    end
    selectedi=[]; count=1;
    while length(selectedi)<nex % take top n, skipping any that are too close
        if skiprest && rest2{movie}(minx(ind(count)))>0
            count=count+1; continue;
        end
        if count>numel(minx), error('Error selecting local minima'); end
        if x2(minx(ind(count)))>min(hrfshift) && ~any(abs(minx(selectedi)-minx(ind(count)))<(2*septhresh))
            selectedi(end+1)=ind(count);
        end
        count=count+1; 
    end
    miny=miny(selectedi);
    minx=minx(selectedi);
    mini=tiedrank(minx); % get their chronological order
    
    %%%%% repeat for extrema in the two quadrants not selected above, (again, x is time & y is product)
    % i.e. those that counteract the dominanat correlation
    if  ~noref && r<0 % for negative correlations, identify only peaks of product, but split into ++ and --
        maxx2=find(islocalmax(pz) & za>0 & zb>0);
        maxy2=pz(maxx2);
        minx2=find(islocalmax(pz) & za<0 & zb<0);
        miny2=pz(minx2);
    else  % for positive correlations, identify only troughs of product, but split into +- and -+
        maxx2=find(islocalmin(pz) & za>0 & zb<0);
        maxy2=pz(maxx2);
        minx2=find(islocalmin(pz) & za<0 & zb>0);
        miny2=pz(minx2);
    end
    %extrema=union(extrema,[maxx2 minx2]);
    
    if noref
        maxx2=[];
        maxy2=[];
        maxi2=[];
        minx2=[];
        miny2=[];
        mini2=[];
    else
        % find nex local counteracting extrema in 3rd quadrant:
        if r>=0 % for positive correlations
            [~, ind]=sort(maxy2,'ascend'); % sort counteracting +- troughs of product, from deepest to shallowest
        else % for negative correlations
            [~, ind]=sort(maxy2,'descend'); % sort counteracting ++ peaks of product, from highest to lowest
        end
        selectedi=[]; count=1;
        while length(selectedi)<nex % take top nex, skipping any that are too close
            if skiprest && rest2{movie}(maxx2(ind(count)))>0
                count=count+1; continue;
            end
            if count>numel(maxx2), error('Error selecting local maxima'); end
            if x2(maxx2(ind(count)))>min(hrfshift) && ~any(abs(maxx2(selectedi)-maxx2(ind(count)))<(2*septhresh))
                selectedi(end+1)=ind(count);
            end
            count=count+1; 
        end
        maxx2=maxx2(selectedi);
        maxy2=maxy2(selectedi);
        maxi2=tiedrank(maxx2);
        
        % find nex local counteracting extrema in 4th quadrant:
        if r<0
            [~, ind]=sort(miny2,'descend'); % sort counteracting -- peaks of product, from highest to lowest
        else
            [~, ind]=sort(miny2,'ascend'); % sort counteracting -+ troughs of product, from deepest to shallowest
        end
        selectedi=[]; count=1;
        while length(selectedi)<nex % take top n, skipping any that are too close
            if skiprest && rest2{movie}(minx2(ind(count)))>0
                count=count+1; continue;
            end
            if count>numel(minx2), error('Error selecting local minima'); end
            if x2(minx2(ind(count)))>min(hrfshift) && ~any(abs(minx2(selectedi)-minx2(ind(count)))<(2*septhresh))
                selectedi(end+1)=ind(count);
            end
            count=count+1; 
        end
        minx2=minx2(selectedi);
        miny2=miny2(selectedi);
        mini2=tiedrank(minx2);
    end
    %%%%%%%
    
    % resort all into chronological order (might speed up reading of video frames)
    allx=[maxx minx maxx2 minx2];
    ally=[maxy miny maxy2 miny2];
    alli=[maxi mini maxi2 mini2];
    ismax=[true(1,nex) false(1,nex), true(1,nex) false(1,nex)]; % is ++ +-, or is -- -+
    iskey=[true(1,nex) true(1,nex), false(1,nex) false(1,nex)]; % quadrants that drive correlation
    [allx, ind]=sort(allx,'ascend');
    ally=ally(ind);
    alli=alli(ind);
    ismax=ismax(ind); iskey=iskey(ind);
    
    % grab the movie frame for each hrfshift of each peak
    fprintf('\nReading all frames to plot'); tic
    anyframe=obj{movie}.readFrame;
    frames=zeros([size(anyframe) numel(allx) length(hrfshift)],'uint8');
    for f=1:numel(allx)
        for s=1:length(hrfshift)
            if (x2(allx(f))-hrfshift(s))>0
                targettime=x2(allx(f))-hrfshift(s);
                obj{movie}.CurrentTime=targettime;
                frame=obj{movie}.readFrame;
                
                if enhancecontrast % contrast enhancement (adds ~0.5 s per frame; see previous versions for comments)
                    lab = rgb2lab(frame);
                    L = lab(:,:,1)/100;
                    lab(:,:,1) = imadjust(L,[0.2; 0.9])*100; % stretches the middle, but maps dark to black and v light to white
                    frame=lab2rgb(lab);
                end
                frames(:,:,:,f,s)=frame;
            end
        end
        fprintf('.')
    end
    fprintf('Took %.1f secs.',toc);
    
    % PLOTTING:
    fprintf('\nPlotting data...'); tic
    
    % prepare 1D figure
    fig=100*movie + 1;
    if isobject(fig); close(fig); end
    tit=sprintf('%s, Movie %d',ROInames{1},movie);
    figure(fig); clf(fig); set(fig,'Clipping','off','Units','Normalized','name',tit,'color','w',...
        'WindowStyle','modal','WindowState','Maximized','ToolBar','none','MenuBar','none','RendererMode','Manual','GraphicsSmoothing','on',...
        'keypressfcn',@capturekeystroke, 'UserData',struct('IsPaused',false));
    
    % create timecourse axes for 1D plot
    %sp(movie,j)=subplot(3,1,2); % for timecourse plot
    sp(movie,1)=subplot('position',[mainplotleftpos 1/3 1-mainplotleftpos-1/nex 1/3]); % for timecourse plot
    ylabel('BOLD response') % will be deleted when line is drawn, but used to get TV width from plot position
    drawnow
    TVwidth=sp(movie,1).Position(1)-sp(movie,1).TightInset(1);
    drawnow limitrate nocallbacks
    
    % plot zero line on 1D plot
    plot(TS{movie}([1 end]),[0 0],'-','color',0.5*[1 1 1],'linewidth',1);
    hold on
    
    % plot movie features (visual, auditory, semantic; at framerate of
    % movie) on 1D plot
    mfh=nan(1,length(mfnames));
    legendhandles=nan(1,length(mfnames)+3); legendnames=cell(1,length(mfnames)+3); % for togglable overlays
    for fn=1:length(mfnames)
        tempmf=rescale(mf{movie}.(mfnames{fn}));
        mfh(fn)=plot(TS{movie}, tempmf*max(abs(toplot(1,:))),'color',cols(fn,:),'HitTest','off','Visible','off');
        legendhandles(fn)=mfh(fn);
        if convolveMovieMeasures
            temp=resample(tempmf(:),1,24);
            legendnames{fn}=sprintf('%s (r=%.2f)',mfnames{fn},corr(temp(~rest{movie}),toplot(1,~rest{movie})','type',ctype));
        else
            legendnames{fn}=mfnames{fn}; %#ok<UNRCH>
        end
    end
    clear tempmf
    
    % plot some other fMRI signals on 1D plot...
    
    gh=plot(x2,gs,'k','HitTest','off','Visible','off'); % ...global signal
    legendhandles(fn+1)=gh;
    legendnames{fn+1}= sprintf('globalBOLD (r=%.2f)',corr(gs(:),toplot(1,:)')); % after GSR, r of ~0.05 due to floating point imprecision?
    
    T=array2table([toplot(1,:)' gs(:)]);
    lm=fitlm(T,'linear','ResponseVar',1);
    gsr=lm.Residuals.Raw; % ...unique signal after global signal regression
    gsr=gsr/max(abs(gsr)) * max(abs(toplot(1,:))); % put on similar scale to non-residualised BOLD
    gsrh=plot(x2,gsr,'-','color',[1 0.5 0],'HitTest','off','Visible','off');
    legendhandles(fn+2)=gsrh;
    legendnames{fn+2}= sprintf('GSRBOLD (r=%.2f)',corr(gsr(:),toplot(1,:)'));
    clear T lm
    
    % ...a reference network (defined above)
    if ~isempty(sem) % also get errorbars
        ci=sem(1,:).*tinv(0.975,size(data{movie},3)-1); % 95% confidence interval
        [rh, ~]=boundedline(x2, toplot(refind,:), ci,'-','transparency',0.2,'alpha','cmap',[0 0 1]);
    else
        rh=plot(x2,toplot(refind,:),'-','color',[0 0 1],'HitTest','off','LineWidth',2);
    end
    legendhandles(fn+3)=rh;
    r=corr(toplot(1,~rest2{movie})', toplot(refind,~rest2{movie})', 'type',ctype);
    legendnames{fn+3}=sprintf('%s (r=%.2f)',REFset,r);
    
    % cofluctuations
    %pz_scaled=pz/max(abs(pz))*max(max(abs(toplot([j refind],:))));
    yyaxis right
    ylim([-1 1]*max(abs(pz)));
    ylabel('z(a).z(b)')
    set(gca,'YColor','m','Linewidth',2,'FontSize',12)
    %rh=plot(x2,pz_scaled,'-','color','m','HitTest','off','LineWidth',2);
    rh=plot(x2,pz,'-','color','m','HitTest','off','LineWidth',2);
    legendhandles(fn+4)=rh;
    legendnames{fn+4}=sprintf('%s (r=%.2f)','prodRefZ',corr(pz(~rest2{movie})',toplot(1,~rest2{movie})','type',ctype));
    yyaxis left
    
    % finally plot target BOLD timecourse on 1D plot, with click callback and attached data:
    if ~isempty(sem) % also get errorbars
        ci=sem(1,:).*tinv(0.975,size(data{movie},3)-1); % 95% confidence interval
        [Bh, ~]=boundedline(x2, toplot(1,:), ci,'-','transparency',0.2,'alpha','cmap',[1 0 0]);
        Bh.LineWidth=2;
        Bh.ButtonDownFcn=@plotCallback;
        Bh.UserData=struct('movie',obj{movie},'marker',[],'fMRI',sp(movie,1),'win',fig,'audio',audios{movie},'soundtable',soundtables{movie});
        meanat=mean( squeeze( abs( toplot(1,:)./sem(1,:) ))); % mean abs t stat across time
        tit=sprintf('%s (mean |t| = %.2f)',tit,meanat);
    else
        Bh=plot(x2,toplot(1,:),[1 0 0],'linewidth',2,'ButtonDownFcn',@plotCallback,...
            'UserData',struct('movie',obj{movie},'marker',[],'fMRI',sp(movie,1),'win',fig,'audio',audios{movie},'soundtable',soundtables{movie}));
    end
    
    % format axes on 1D plot
    axis tight; box off
    tith=title(tit,'interpreter','none','color','r');
    xlabel('Time (s)','FontSize',10);
    ylabel(sprintf('Mean BOLD response (z) to movie %d', movie),'FontSize',10)
    set(gca,'YColor','k','Linewidth',2,'FontSize',12)
    if ~showlegend
        tith.Visible='off';
    end
    
    % set ylim on 1D plot to the max across networks
    %mx=max(max(abs(toplot(~cellfun(@isempty,regexp(ROInames,ROIset, 'once')),:))));
    mx=max(max(abs(toplot([1 refind],:))));
    mx=max(abs(ylim));
    if any(toplot(:)<0)
        ylim([-1 1]*mx);
    else
        ylim([0 mx])
    end
    
    % add patches to mark early and late "rest" and restart
    resttime=[0 timepoints{movie}(2:2:end)];
    for step=1:3
        if step==3, resttime(end)=[]; end
        polyx=[resttime; resttime; resttime+10; resttime+10];
        polyy=repmat([ylim fliplr(ylim)]',1,size(polyx,2));
        patch(polyx,polyy,rcols(step,:),'EdgeColor','none','FaceAlpha',0.2);
        resttime=resttime+10;
    end
    
    % switch to 2nd yaxis for prodz, for peak labelling
    yyaxis right
    
    drawnow;
    [allxf, allyf]=axescoord2figurecoord(x2(allx),ally); % for the 1D figure (convert TRs to seconds into movie)
    ids=repmat(1:nex,1,4); % for the 2D figure, list of numeric IDs for top nex per quadrant
    ids=ids(ind);
    
    %%%%% in separate figure, plot frames in 2D activation space and
    %%%%% highlight peaks of prodZ
    if ~noref
        fig2=figure(10*movie + 1); clf(fig2) % for 2D plot
        set(fig2,'Clipping','off','Units','Normalized','color','w','WindowState','Maximized',...
            'ToolBar','none','MenuBar','none','RendererMode','Manual','GraphicsSmoothing','on'); % 'WindowStyle','modal',
        ax0=axes('position',[0.025 0.035 0.95 0.95],'NextPlot','add');
        
        % add correlations in title (faster before data? needs 'nextplot' to not be default 'replace')
        V=xDF(toplot([1 refind],:),length(toplot));
        % see Afyouni, 2018; p values are corrected for temporal autocorrelation.
        % THESE ARE NOT APPROPRIATE FOR TEMPORALLY MASKED/SPLICED DATA, SO ARE CALCULATED ON THE FULL
        % DATA. RECALCULATE Z AND P USING FULL-DATA-V AND REDUCED-DATA-R BUT BE AWARE THIS IS AN APPROXIMATION
        tit={sprintf('Movie %d',movie)};
        for tmask=1:3
            if tmask==1
                r=corr(toplot(refind,:)',toplot(1,:)');
                txt='All';
            elseif tmask==2
                r=corr(toplot(refind,~rest2{movie})', toplot(1,~rest2{movie})');
                txt='Excluding Rest/Restart';
            else
                r=corr(toplot(refind,rest2{movie}>0)',toplot(1,rest2{movie}>0)');
                txt='Only Rest/Restart';
            end
            rf      = atanh(r);
            sf      = V(1,2)./((1-r.^2).^2);
            rzf     = rf./sqrt(sf);
            f_pval  = 2 .* normcdf(-abs(rzf));  %both tails
            tit{tmask+1}=sprintf('%s: r=%.2f, xDF p=%.3f',txt,r,f_pval);
        end
        title(join(tit,';       '))
        drawnow
        
        ax0.Units='pixels'; % change units to pixels so they don't get moved on resize?
        
        % scatter plot all points
        colcap=1.5; % 1.5 is roughly the intersection of the unity line with critical values; saturate beyond this
        cols=rescale(za(:),'InputMin',-colcap,'InputMax',colcap); % y axis linked to redness
        cols(:,3)=rescale(zb,'InputMin',-colcap,'InputMax',colcap); % x axis linked to blueness
        cols(:,2)=rest2{movie}>0; %zeros(size(za)); % rest/restart linked to greenness
        cols(rest2{movie}==1,[1 3])=0; % rest onset is bright green
        cols(rest2{movie}==2,[1 3])=0.5; % later rest is paler green
        cols(rest2{movie}==1,1)=rcols(1,1); cols(rest2{movie}==1,2)=rcols(1,2); cols(rest2{movie}==1,3)=rcols(1,3); % rest onset is darker green
        cols(rest2{movie}==2,1)=rcols(2,1); cols(rest2{movie}==2,2)=rcols(2,2); cols(rest2{movie}==2,3)=rcols(2,3); % later rest is paler green
        cols(rest2{movie}==3,1)=rcols(3,1); cols(rest2{movie}==3,2)=rcols(3,2); cols(rest2{movie}==3,3)=rcols(3,3); % restart is yellow
        
        alpha=rescale(abs(pz));
        sh=scatter(ax0,zb,za,400*alpha+10,cols,'filled');
        axis tight square
        set(ax0,'YColor','k','Linewidth',2,'FontSize',12)
        
        %xlim([min(zb(~rest{movie})) max(zb(~rest{movie}))]); % tighten view to just movie period?
        %ylim([min(za(~rest{movie})) max(za(~rest{movie}))]);
        sh.MarkerFaceAlpha=0.5; sh.MarkerEdgeColor='none'; % can't do variable alpha?
        
        drawnow
        fprintf('Took %.1f secs.',toc);
    end
    
    fprintf('\nLabelling movie frames at peaks'); tic
    
    shifts=rescale(1:length(hrfshift),-1, 1);
    fontcol=nan(numel(allx),3); % to be used for both figures
    linestyle=cell(numel(allx),1); % to be used for both figures
    fontweight=cell(numel(allx),1);
    fontsize=nan(numel(allx),1);
    markersize=nan(numel(allx),1);
    for f=1:numel(allx)
        fontcol(f,:)=[za(allx(f))>0 0 zb(allx(f))>0];
        pzf=za(allx(f))*zb(allx(f));
        if noref
            emphasise=true;
        else
            if iskey(f) % in the quadrants that drive the correlation
                emphasise=pzf<criti(1) | pzf>criti(2); % which points contribute to r deviating from zero
            else % in the other quadrants
                emphasise=pzf<critc(1) | pzf>critc(2); % which points drive the oberved correlation back towards zero
            end
        end
        
        if emphasise
            fontsize(f)=20;
            markersize(f)=24;
            linestyle{f}='--';
            fontweight{f}='bold';
        else
            fontsize(f)=15;
            markersize(f)=20;
            linestyle{f}=':';
            fontweight{f}='normal';
        end
    end
    
    if ~noref
        % prepare movie frame positions for 2D plot
        % movie frames preceding peaks (but plot label at time of peak)
        
        posf=fitplots2([ceil(nex/2) 2]);
        sidex=cellfun(@(x) x(1)+x(3)/2,posf);
        sidey=cellfun(@(x) x(2)+x(4)/2,posf);
        
        % plot video frames, and lines/labels linking them to timecourses:
        % first in 2D figure, which should already have focus
        sizex= 0.7/nex;    sizey =sizex *3/4; % for frame size in 2D figure
        
        for f=1:numel(allx)
            
            % add label to 2D figure
            ch=plot(ax0, double(zb(allx(f))), double(za(allx(f))),'o','Color',fontcol(f,:), 'MarkerSize', markersize(f),'LineWidth',2,'MarkerFaceColor','w');
            ch.ZData=2;
            text(ax0, double(zb(allx(f))), double(za(allx(f))) ,3,num2str(ids(f)),'HorizontalAlignment','center','VerticalAlignment','middle',...
                'FontWeight','bold','FontSize',fontsize(f),'Color',fontcol(f,:));
            
            for s=1:length(hrfshift) % plot frame at each shift
                if zb(allx(f))<0
                    tempx=sidex(ids(f))/4;
                else
                    tempx=sidex(ids(f))/4+0.75;
                end
                if za(allx(f))<0
                    tempy=sidey(ids(f))*0.45+0.025;
                else
                    tempy=sidey(ids(f))*.45+0.525;
                end
                ax=axes(fig2,'position',[tempx-sizex/2+shifts(s)*(sizex*0.233), tempy-sizey/2-shifts(s)*(sizey*0.233), sizex, sizey]);
                
                image(frames(:,:,:,f,s),'parent',ax,'Alphadata',0.8);
                axis image off
                txt=sprintf('%d (%.1fs)',ids(f),x2(allx(f)));
                if s==1
                    ttith=title(txt,'FontSize',max(12,fontsize(f)-6),'Color',fontcol(f,:),'FontWeight',fontweight{f});
                    ttith.HorizontalAlignment='center'; % 'left' might overlap with images 
                    ttith.Position(1)=0;
                end
            end % next hrf shift
            if ~mod(f,2)
                drawnow; % Helps to see progress
            end
            
            
            fprintf('.')
        end % next peak to annotate
        
        fprintf('Took %.1f secs.',toc);
        fprintf('\nAdorning 2D figure'); tic % faster after frames, so not refreshed with each drawnow
        
        axes(ax0);
        ylabel(['z-scored mean ' regexprep(ROInames{1},{'17Networks_\d+'},{'Yeo17'})],'interpreter','none')
        xlabel(['z-scored mean ' regexprep(REFset,{'17Networks_\d+'},{'Yeo17'})],'interpreter','none')
        hold on
        plot([0 0],ylim,'k-','linewidth',1)
        plot(xlim,[0 0],'k-','linewidth',1)
        
        % add direction of trajectory
        qh=quiver(zb,za,gradient(zb),gradient(za),2); % final number scales their length
        qh.Color=[.7 .7 .7];
        
        % add markers for start and end?
        %starth=scatter(zb(1),za(1),50,'k','filled','marker','>');
        %stoph=scatter(zb(end),za(end),50,'k','filled','marker','square');
        
        % add a line with similarly interpolated colours
        % not sure why, not only transparancy fails, but it makes
        % the scatter points opaque?
        zz=ones(size(za));
        surface([zb; zb],[za; za],[zz; zz],repmat(permute(cols,[3 1 2]),2,1,1),...
            'edgecol','interp','facecol','no','LineWidth',1,'EdgeAlpha','interp','AlphaData',[zz; zz]*0.2,'facealpha','interp','AlphaDataMapping','none');
        
        drawnow
        
        % hide data that are not extrema?
        %sh.CData(setdiff(1:length(sh.CData),extrema),:)=nan;
        %lh.CData(setdiff(1:length(sh.CData),extrema),:)=nan;
        %qh.XData(:,setdiff(1:length(sh.XData),extrema))=nan;
        
        % add iso-probability contours at 95% critical values for product of independent and correlated normals
        zarange=linspace(min(za),max(za),1000);
        zbrange=linspace(min(zb),max(zb),1000);
        [gridy, gridx]=ndgrid(zarange,zbrange);
        gridp=gridy.*gridx;
        [C, chi]=contour(gridx, gridy,gridp,round(criti,2),'k--','LineWidth',2); clabel(C, chi,'color','k','LabelSpacing',Inf,'FontSize',12);
        [C, chc]=contour(gridx, gridy,gridp,round(critc,2),'m--','LineWidth',2); clabel(C, chc,'color','m','LabelSpacing',Inf,'FontSize',12);
        drawnow
        fprintf('Took %.1f secs.',toc);
    end % if ~noref
    
    % now on 1D figure
    figure(fig)
    sizex1=1.2*1/(nex); sizey1=sizex1*3/4; % for frame size in 1D figure
    for f=1:numel(allx)
        if iskey(f)
            if ismax(f) % top row
                tempy=1- 2*1/(3*(ns+1));
            else % bottom row
                tempy=2* 1/(3*(ns+1)); % centre of frame strip
            end
            tempx=alli(f)/(nex+1);
            for s=1:length(hrfshift)
                % plot frame
                ax=axes('position',[tempx-sizex1/2+shifts(s)*(sizex1*0.1), tempy-sizey1/2-shifts(s)*(sizey1*0.8), sizex1, sizey1]);
                image(frames(:,:,:,f,s),'parent',ax,'Alphadata',0.8);
                axis image off
                if f==find(ismax.*iskey,1) || f==find(~ismax.*iskey,1)
                    title(sprintf('t - %d s ',hrfshift(s)),'Position',[0 mean(ylim) 0],'HorizontalAlignment','right','VerticalAlignment','top','FontSize',12,'FontWeight','bold');
                end
                
                % add annotation line
                if (ismax(f) && s==length(hrfshift)) || (~ismax(f) && s==1)
                    drawnow;
                    if ismax(f)
                        [fxf, fyf]=axescoord2figurecoord(mean(xlim),max(ylim));
                    else
                        [fxf, fyf]=axescoord2figurecoord(mean(xlim),min(ylim));% bottom of frame
                    end
                    annotation('line',[allxf(f) fxf],[allyf(f) fyf],'linestyle',linestyle{f},'color',fontcol(f,:),'HitTest','off');
                    
                    adim=[fxf-0.01/screensize(3)*screensize(4), fyf-0.01, 0.02/screensize(3)*screensize(4), 0.02];
                    annotation('ellipse', adim,'Color',fontcol(f,:),'LineWidth',2,'FaceColor','w');
                    annotation('textbox',adim,'String',num2str(ids(f)),'color',fontcol(f,:),'edgecolor','none','FontSize',14,... % peak number
                        'HorizontalAlignment','center','VerticalAlignment','middle','FontWeight','bold');
                    
                    if ismax(f)
                        pdim=[fxf+0.02/screensize(3)*screensize(4), fyf-0.02, 0.08/screensize(3)*screensize(4), 0.02];
                    else
                        pdim=[fxf+0.02/screensize(3)*screensize(4), fyf, 0.08/screensize(3)*screensize(4), 0.02];
                    end
                    annotation('textbox',pdim,'String',sprintf('%.1f s',x2(allx(f))),'color',fontcol(f,:),'edgecolor','none','FontSize',12,... % peak time
                        'HorizontalAlignment','left','VerticalAlignment','middle','FontWeight','normal');
                end
            end  % next hrf shift
            
        end % on this figure, just peaks that drive correlation
        fprintf('.')
    end % next peak to annotate
    
    fprintf('Took %.1f secs.',toc);
    
    fprintf('\nAdding legend, TV screen, rendering etc...'); tic
    
    % add interactive legend (cannot be located 'outside' without
    % changing axis position??) to 1D figure
    axes(sp(movie,1));
    yyaxis left % focus left axis for interactive functions
    warning off MATLAB:Axes:UnsupportedDataAspectRatio
    legh=legend(legendhandles,legendnames,'location','best','orientation','horizontal','box','on','autoupdate','off','ItemHitFcn',@toggleVisibility,'NumColumns',11);
    if ~showlegend
        legh.Visible='off';
    end
    
    % add TV screen at left of 1D figure
    TV=axes('position',[0 1/3 TVwidth 1/3]); axis off % for surfing
    Bh.UserData.TV=TV;
    
    % add rendering of ROI location at right of 1D figure
    sax=gobjects(1,2);
    if issubcortical(1)~=round(issubcortical(1))
        fprintf('\nWarning: ROI set is mixture of cortical/subcortical types; not plotting.')
    elseif issubcortical(1)>=1
        % hard to plot both chosen and reference ROIs on same slices?
        % for now, just former...
        %xyz=ciftidiminfo.models{subcorticalmodels.(ROInames{1})(1)}.voxlist+1; % Now defined above
        bin=zeros(ciftidiminfo.vol.dims); bin_ref=zeros(ciftidiminfo.vol.dims);
        bin_ref(sub2ind(ciftidiminfo.vol.dims,xyz_ref(1,:),xyz_ref(2,:),xyz_ref(3,:)))=1; 
        bin(sub2ind(ciftidiminfo.vol.dims,xyz(1,:),xyz(2,:),xyz(3,:)))=1;
        for iview=1:2
            sax(iview)=axes('position',[nex/(nex+1) (iview+1)/6 1/(nex+1) 1/6]); % stacked at right of timecourse
            ranges=repmat(median(xyz,2),1,2); % median coordinate of ROI(s)
            ranges(setdiff(1:3,iview),1)=min(xyz(setdiff(1:3,iview),:),[],2) - 2*range(xyz(setdiff(1:3,iview),:),2); % extend lower limit beyond ROI in this plane
            ranges(setdiff(1:3,iview),2)=max(xyz(setdiff(1:3,iview),:),[],2) + 2*range(xyz(setdiff(1:3,iview),:),2); % extend upper limit beyond ROI in this plane
            ranges=max(ranges,1); ranges=min(ranges,repmat(ciftidiminfo.vol.dims',1,2)); % but check not out of brain vol
            t1wc=rot90(squeeze(ssY(ranges(1,1):ranges(1,2),ranges(2,1):ranges(2,2),ranges(3,1):ranges(3,2)))); % T1 image
            mask=rot90(squeeze(bin(ranges(1,1):ranges(1,2),ranges(2,1):ranges(2,2),ranges(3,1):ranges(3,2)))); % ROI image
            mask_ref=rot90(squeeze(bin_ref(ranges(1,1):ranges(1,2),ranges(2,1):ranges(2,2),ranges(3,1):ranges(3,2)))); % ROI image
            imagesc(t1wc);
            hold on
            [~, ch]=contour(mask_ref,[0.5 0.5],'b'); ch.LineWidth=2;
            [~, ch]=contour(mask,[0.5 0.5],'r');   ch.LineWidth=2;
            axis ij equal off; colormap gray
        end
    else
        for iview=1:2
            sax(iview)=axes('position',[nex/(nex+1) (iview+1)/6 1/(nex+1) 1/6]); % stacked at right of timecourse
            hp = patch(struct('vertices',vertices,'faces',faces),...
                'FaceColor', 'b', 'EdgeColor', 'none',...
                'Parent',sax(iview),...
                'facelighting','gouraud', 'backfacelighting','reverselit',...
                'ambientStrength',0.1,'diffuseStrength',0.5,'SpecularStrength',0.2,'specularColorReflectance',0);
            cdat=2/3*double(max(vertex_ids(orig_roiind(1:(numel(orig_roiind)/2)),:),[],1));
            if issubcortical(refind) ==0 % add (union of) reference ROI(s) if (all are) also cortical
                cdat = cdat+ 1/3*double(max(vertex_ids(orig_refind(1:(numel(orig_refind)/2)),:),[],1));
            end
            set(hp,'FaceVertexCData',cdat(:), 'FaceColor','flat')
            camlight('headlight');
            view([iview*180-90 0]);
            camlight('headlight');
            lighting(sax(iview),'gouraud');
            colormap([1 1 1; 0 0 1; 1 0 0; 1 0 1]); caxis([0 1]);
        end
        axis(sax,'equal','tight','off');
    end
    
    set(fig,'WindowStyle','normal');
    if ~noref
        set(fig2,'WindowStyle','normal');
    end
    drawnow
    
    if savefigures
        pause(0.05)
        %fname=fullfile(here,sprintf('Movie%d_network_%s.png',movie,regexprep(ROInames{j},{' ','/'},{'_','_'})));
        fname=fullfile(outdir,sprintf('Movie%d_Peaks_of_%s_%s_vs_%s_1D.png',movie,char(join(parcellation)),ROIset,REFset));
        print(fig,fname,'-dpng')
        if ~noref
            %fname=fullfile(here,sprintf('Movie%d_network_%s_vs_Ref.png',movie,regexprep(ROInames{j},{' ','/'},{'_','_'})));
            fname=fullfile(outdir,sprintf('Movie%d_Peaks_of_%s_%s_vs_%s_2D.png',movie,char(join(parcellation)),ROIset,REFset));
            print(fig2,fname,'-dpng')
        end
    end
    
    fprintf('Took %.1f secs.',toc);
    
    %%%% save video clip?
    if saveclips>0
        fprintf('\nSaving clips preceding peaks:');
        tmin=saveclipcontext(1)+max(hrfshift); % how far back from peak is start of clip (e.g. 4 + 12 = 16 s)
        tmax=min(hrfshift)-saveclipcontext(2); % how far back from peak is end of clip (e.g. 4 - 4 = 0 s)
        
        for f=1:numel(allx)
            
            % to include audio, must be .avi (in which "quality" & "CompressionFactor parameters are ignored)
            clipname=sprintf('Movie%d_%s-ZBP_%s-ZAP_%02d_SIG_%.1fto%.1fs.avi',movie,REFset, ROIset, ids(f),x2(allx(f))-tmin,x2(allx(f))-tmax);
            if zb(allx(f))<0
                clipname=regexprep(clipname,'ZBP','LO');
            else
                clipname=regexprep(clipname,'ZBP','HI');
            end
            if za(allx(f))<0
                clipname=regexprep(clipname,'ZAP','LO');
            else
                clipname=regexprep(clipname,'ZAP','HI');
            end
            if ~emphasise
                clipname=regexprep(clipname,'SIG_','');
            end
            clippath=fullfile(clipdir,clipname);
            if ~exist(clippath,'file') % don't overwrite, because very slow, especially with activation)
                if saveclips==2
                    videoFWriter = vision.VideoFileWriter(clippath,'FileFormat','AVI','AudioInputPort',true,'FrameRate',FrameRate,...
                        'AudioCompressor','None (uncompressed)','VideoCompressor','None (uncompressed)'); % options 'None (uncompressed)', 'DV Video Encoder', or 'MJPEG Compressor'
                else
                    videoFWriter = vision.VideoFileWriter(clippath,'FileFormat','AVI','AudioInputPort',true,'FrameRate',FrameRate,...
                        'AudioCompressor','None (uncompressed)','VideoCompressor','DV Video Encoder'); % options 'None (uncompressed)', 'DV Video Encoder', or 'MJPEG Compressor'
                    % DV Video Encoder works for video but not audio; fastest and smallest file size
                end
                
                targettime=x2(allx(f))-tmin; % actual time into movie to start clip
                targettime_end=x2(allx(f))-tmax; % and to end clip
                highlightrange=x2(allx(f))-[max(hrfshift) min(hrfshift)]; % and to highlight clip
                
                obj{movie}.CurrentTime = targettime;
                currenttime=obj{movie}.CurrentTime;
                
                audio=audios{movie}(floor(targettime*16000):ceil(targettime_end*16000));
                i=0;
                
                if saveclips==2 && ~noref
                    tfh=figure(99); clf(99)
                    tfh.Position=[100 100 1024 720];
                    sf=0.59; % this scale factor leaves an approximately square region beside it
                    marg=0.06; % margin around graphs (to allow space for axis labels) as proportion of figure
                    ax1=axes('position',[0 0 sf sf]);
                    imshow(imresize(zeros(720,1024,3),sf));
                    
                    ax2=axes('position',[marg marg+sf 1-2*marg 1-sf-2*marg]);
                    activationstart=allx(f)-tmin*2; % activation plotted from start of clip
                    activationstop=allx(f) + 4*2; % to 4 s after peak
                    tempdat=[za(activationstart:activationstop); zb(activationstart:activationstop)]; % za is main; zb is ref
                    ma=max(abs(tempdat(:)));
                    plot(ax2,[1 1]* targettime, [-1 1]*ma,'k','linewidth',1); hold on % vertical marker for clip start
                    plot(ax2,[1 1]* targettime_end, [-1 1]*ma,'k','linewidth',1); % vertical marker for clip end
                    plot(ax2,[targettime targettime_end+4],[0 0],'k','linewidth',1); % horizontal zero line
                    axis(ax2,'tight')
                    acti=4*2; % plot up to this activation index
                    dat1h=plot(ax2,x2(activationstart:(activationstart-1+acti)),tempdat(2,1:acti),'-bo','linewidth',2); % reference region
                    dat2h=plot(ax2,x2(activationstart:(activationstart-1+acti)),tempdat(1,1:acti),'-ro','linewidth',2); % main region
                    ylabel('z-scored mean BOLD')
                    xlabel('time in run (s)')
                    
                    ax3=axes('position',[marg+sf marg 1-sf-2*marg sf-2*marg]);
                    plot(ax3,[-1 1]*ma,[0 0],'k','linewidth',1); hold on; % horizontal zero line
                    plot(ax3,[0 0],[-1 1]*ma,'k','linewidth',1);
                    axis(ax3,'tight','image'); set(ax3,'XTick',[],'ytick',[]);
                    ylabel(['z-scored mean ' regexprep(ROInames{1},{'17Networks_\d+'},{'Yeo17'})],'interpreter','none')
                    xlabel(['z-scored mean ' regexprep(REFset,{'17Networks_\d+'},{'Yeo17'})],'interpreter','none')
                    zz=ones(1,8);
                    dat3h=surface(repmat(tempdat(2,1:acti),2,1),repmat(tempdat(1,1:acti),2,1),[zz; zz],repmat(permute(cols(activationstart:(activationstart-1+acti),:),[3 1 2]),2,1,1),...
                        'edgecol','interp','facecol','no','LineWidth',2);
                    dat4h=plot(tempdat(2,acti),tempdat(1,acti),'o','markeredgecolor','none','markerfacecolor',cols(activationstart-1+acti,:));
                    ax3.XColor='b';
                    ax3.YColor='r';
                    ax3.Box='off';
                    
                    tfh.WindowStyle='Modal';
                end
                
                while currenttime < targettime_end
                    i=i+1;
                    CData=readFrame(obj{movie}); % get current frame
                    % add coloured border to indicate time windows of interest:
                    if (currenttime<min(highlightrange)) || (currenttime>max(highlightrange))
                        bcol=0; % black border for "context" periods
                    else
                        bcol=255; % white border for "key" periods
                    end
                    CData=padarray(CData,[20 20],bcol,'both');
                    %CData=imresize(CData,0.5); % Would be nice to change output size, but seems fixed to 720x480 regardless of what is passed to the videowriter? 
                    
                    if saveclips==2 && ~noref % add activation timecourses
                        if ~mod(i,12)
                            acti=acti+1; % every 12th frame is a 0.5 s activation increment
                        end
                        ax1.Children.CData=imresize(CData,sf);
                        
                        dat1h.XData=x2(activationstart:(activationstart-1+acti));
                        dat1h.YData=tempdat(2,1:acti);
                        dat2h.XData=x2(activationstart:(activationstart-1+acti));
                        dat2h.YData=tempdat(1,1:acti);
                        dat3h.XData=repmat(tempdat(2,1:acti),2,1);
                        dat3h.YData=repmat(tempdat(1,1:acti),2,1);
                        dat3h.ZData=ones(size(dat3h.YData));
                        dat3h.CData=repmat(permute(cols(activationstart:(activationstart-1+acti),:),[3 1 2]),2,1,1);
                        dat4h.XData=tempdat(2,acti);
                        dat4h.YData=tempdat(1,acti);
                        dat4h.Color=cols(activationstart-1+acti,:);
                        
                        F=getframe(99);
                        CData=F.cdata;
                    end
                    
                    aframestart=floor((i-1)/FrameRate*16000)+1;
                    aframestop=aframestart+aframelen;
                    videoFWriter(CData,audio(aframestart:aframestop));
                    currenttime=obj{movie}.CurrentTime;
                end % next frame
                
                videoFWriter.release;
                if saveclips==2 && ~noref
                    delete(tfh)
                end
            end % if doesn't already exist
            fprintf('.')
        end % next peak/clip
    end % if save clips
    %%%%%%%%
    
end % next movie

try
    EqualiseAxes(997)
catch
end

DockUndock('undock')

return



function plotCallback(src,event)

% unpause
set(src.UserData.win,'UserData',struct('IsPaused',false));

% delete any existing time markers
if ~isempty(src.UserData.marker)
    try
        delete(src.UserData.marker)
    catch
    end
end

% delete any existing audioplayer
if isfield(src.UserData,'ap')
    if src.UserData.ap.isvalid
        src.UserData.ap.stop;
        src.UserData.ap.delete;
    end
    src.UserData=rmfield(src.UserData,'ap');
end

% set target time
hrfshift=4;
markercol=[.5 0 0];
targettime=event.IntersectionPoint(1)-hrfshift; % should be in axis units, which are already s into movie (rather than TR indices, so no need to subtract TRshift here)
if targettime<=0; return; end

if event.Button==1 % regular left click, jump to frame
    
    % plot marker and line
    src.UserData.marker(1)=plot(event.IntersectionPoint(1),event.IntersectionPoint(2),'^',...
        'MarkerEdgeColor',markercol,'MarkerFaceColor',markercol,'HitTest','off');
    src.UserData.marker(2)=plot([1 1]*event.IntersectionPoint(1),[min(src.YData) max(src.YData)],':','color',markercol,'linewidth',2,'HitTest','off','parent',src.UserData.fMRI);
    
    % display target frame
    src.UserData.movie.CurrentTime=targettime;
    image(src.UserData.movie.readFrame,'parent',src.UserData.TV)
    
    % score sounds
    soundregion=src.UserData.soundtable.TimeStamps(:,1)<=targettime & src.UserData.soundtable.TimeStamps(:,2)>targettime;
    if ~any(soundregion)
        audtxt='[Unknown noise]';
    else
        currentsounds=vertcat(src.UserData.soundtable.Results{soundregion});
        ns=length(currentsounds.Sounds);
        audtxt='';
        for si=1:ns
            audtxt=sprintf('%s %s (%.2f); ',audtxt,currentsounds.Sounds{si},currentsounds.AverageScores(si));
        end
    end
    
    axis(src.UserData.TV,'off','image')
    title(src.UserData.TV,{sprintf('t - %.0f s (%.0f s)',hrfshift,targettime),audtxt},'color',markercol);
    
elseif event.Button==2 % middle click to clear the TV
    cla(src.UserData.TV);
elseif event.Button==3 % right click, then click another point to select chunk of video
    
    % get 2nd input and plot window boundaries
    src.UserData.marker=plot([1 1]*event.IntersectionPoint(1),[min(src.YData) max(src.YData)],':','color',markercol,'linewidth',2,'HitTest','off','parent',src.UserData.fMRI);
    [endx,~] = ginput(1);
    src.UserData.marker(2)=plot([1 1]*endx,[min(src.YData) max(src.YData)],':','color',markercol,'linewidth',2,'HitTest','off','parent',src.UserData.fMRI);
    targettime_end = endx-hrfshift;
    
    if targettime_end<targettime
        temp=targettime;
        targettime=targettime_end;
        targettime_end=temp;
    end
    if targettime<=0 || ((targettime_end+hrfshift)>numel(src.YData))
        delete(src.UserData.marker)
        return;
    end
    
    % prepare TV and progress marker
    image(zeros(src.UserData.movie.Height,src.UserData.movie.Width),'parent',src.UserData.TV);
    th=title(src.UserData.TV,sprintf('t - %.0f s',hrfshift),'color',markercol);
    axis(src.UserData.TV,'off','image')
    src.UserData.marker(3)=plot(targettime+hrfshift,src.YData(round((targettime+hrfshift)*2)),'^',...
        'MarkerEdgeColor',markercol,'MarkerFaceColor',markercol,'HitTest','off','parent',src.UserData.fMRI);
    
    src.UserData.movie.CurrentTime=targettime;
    currenttime=targettime;
    nframe=ceil(24*(targettime_end-currenttime));
    drawnow nocallbacks %limitrate
    %tStop=nan(1,nframe); % to store frame display times
    
    % score sounds
    lastsoundregion=nan;
    audtxt=cell(1,nframe);
    frametimes=targettime:(1/24):targettime_end;
    ts=src.UserData.soundtable.TimeStamps;
    sc=src.UserData.soundtable.Results;
    for i=1:numel(frametimes)
        soundregion=ts(:,1)<=frametimes(i) & ts(:,2)>frametimes(i);
        if isequal(soundregion, lastsoundregion)
            audtxt{i}=audtxt{i-1};
        else
            if ~any(soundregion)
                audtxt{i}='[Unknown noise]';
            else
                currentsounds=vertcat(sc{soundregion});
                ns=length(currentsounds.Sounds);
                audtxt{i}='';
                for si=1:ns
                    audtxt{i}=sprintf('%s %s (%.2f); ',audtxt{i},currentsounds.Sounds{si},currentsounds.AverageScores(si));
                end
            end
            lastsoundregion=soundregion;
        end
    end
    
    src.UserData.TV.Children.CData=readFrame(src.UserData.movie); % seeking to 1st frame could take a moment, so do this before loading/playing audio?
    
    audio=src.UserData.audio(floor(targettime*16000):ceil(targettime_end*16000));
    src.UserData.ap=audioplayer(audio, 16000);
    src.UserData.ap.play;
    astart=tic;
    
    i=0;
    try
        while currenttime <= targettime_end
            tStart = tic;
            
            i=i+1;
            src.UserData.TV.Children.CData=readFrame(src.UserData.movie);
            
            if ~mod(i,24) % MRI data at 1 Hz; video frames at 24 Hz
                src.UserData.marker(3).XData=currenttime + hrfshift;
                src.UserData.marker(3).YData=src.YData(round((currenttime+hrfshift)*2));
            elseif ~mod(i,4) && exist('th','var') && th.isvalid
                th.String={sprintf('t - %.0f s (%.0f s)',hrfshift,currenttime),audtxt{i}};
            end
            
            %drawnow % not helpful!
            % (CData already gets updated and displayed, and should take less than one frame duration,
            % hence the pause below. drawnow would update all elements of
            % all figures, which takes longer than a frame.)
            
            status=get(src.UserData.win,'UserData');
            if status.IsPaused
                src.UserData.ap.pause;
                fprintf('\nPaused at t=%.1f s',currenttime)
                set(src.UserData.win,'WindowStyle','modal');
                while status.IsPaused
                    drawnow;
                    status=get(src.UserData.win,'UserData');
                end
                set(src.UserData.win,'WindowStyle','normal');
                drawnow nocallbacks
                src.UserData.ap.resume;
            end
            
            slippage=toc(astart)-(currenttime-targettime); % total video delay relative to truth (and assumed audio)
            tStop = toc(tStart); % time taken on this frame
            if tStop>(1/24)
                %fprintf('\nFrame drawing took %.1f ms.',tStop(i)*1000)
            else
                %fprintf('\nFrame drawing took %.1f ms.',tStop(i)*1000)
                pause(1/24 - tStop - slippage);
            end
            
            currenttime=src.UserData.movie.CurrentTime;
            
        end % next frame
        
    catch
        %error('failed to play video')
    end
    
    if isfield(src.UserData,'ap')
        if src.UserData.ap.isvalid
            src.UserData.ap.stop;
            src.UserData.ap.delete;
        end
        src.UserData=rmfield(src.UserData,'ap');
    end
    
    set(src.UserData.win,'UserData',struct('IsPaused',false));
    
    drawnow
    fprintf('\nStopped at t=%.1f s',currenttime)
    
end % left or right click

return

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function toggleVisibility(~,event)
% This callback from a legend entry toggles the visibility of the line

if strcmp(event.Peer.Visible,'on')   % If current line is visible
    event.Peer.Visible = 'off';      %   Set the visibility to 'off'
else                                 % Else
    event.Peer.Visible = 'on';       %   Set the visibility to 'on'
end

return

function capturekeystroke(src,~)
src.UserData.IsPaused=~src.UserData.IsPaused;
return

function out=pcapernetwork(nxtxs)
nr=size(nxtxs,1); % # networks
out=nan(nr,size(nxtxs,2));
for  j = 1:nr
    txs=squeeze(nxtxs(j,:,:));
    [~,score,~,~,~] = pca(txs,'NumComponents',1);
    if corr(score(:),mean(nxtxs(j,:,:),3)')<0
        score=score*-1;
    end
    out(j,:)=score;
end
return

function out=representativesub(nxtxs,MostOrLeast,ROInames,alldata,badsubs,doGSR)

% if cell array of data per movie is passed as alldata, then concatenate and override x.
% Some subjects have missing MSMall data for some movies, so use 4th input to match up subjects and exclude any with partial data
if nargin>3 && ~isempty(alldata)
    thismovie=cellfun(@(x) isequal(nxtxs,x),alldata);
    assert(sum(thismovie)==1);
    for m=1:length(alldata)
        temp=nan(size(alldata{m},1),size(alldata{m},2),numel(badsubs{1}));
        temp(:,:,~badsubs{m})=alldata{m};
        alldata{m}=temp;
    end
    nxtxs=alldata{thismovie};
    alldata=cat(2,alldata{:});
    drop=squeeze(any(isnan(alldata(1,:,:)),2));
    alldata(:,:,drop)=[];
    nxtxs(:,:,drop)=[];
    txt=sprintf('%s representative subject across all movies is',MostOrLeast);
else
    alldata=nxtxs;
    txt=sprintf('%s representative subject for current movie is',MostOrLeast);
end

ns=size(alldata,3); % # subjects
v=reshape(alldata,[],ns); % concatenate networks and timepoints
m=mean(v,2);
r=corr(v,m); % correlation of each subject with mean

gs=squeeze(mean(alldata(contains(ROInames,'17'),:,:)));  % ... global signal (averaged across Yeo17 networks, excluding Medial Wall and Core MD)
rg=nan(1,ns);
for s=1:ns
    rg(s)=mean(corr(alldata(:,:,s)',gs(:,s))); % mean of correlations of each network of this subject with their global signal
end
figure(99); scatter(rg,r,'filled'); xlabel('mean correlation of each network with global signal'); ylabel('correlation of all networks with group mean')

switch MostOrLeast
    case 'most'
        [~,ind]=max(r);
    case 'least'
        [~,ind]=min(r);
end
out=nxtxs(:,:,ind);
fprintf('\n%s %d',txt,ind)

if exist('doGSR','var') && doGSR
    nt=size(out,2);
    K=ones(nt,1); % just constant term (could implement temporal filter etc)
    X=[gs(:,ind), K];
    R  = eye(nt) - X*pinv(X); % residual forming matrix
    out=(R*out')';
end

return

function [out, sem,ss]=csrMeanOrVar(nxtxs,MeanOrVar,doGSR,HPFcp,doDeriv)
% confound signal regression, optionally including global signal
% regression, high-pass filtering, and final conversion to derivative.
% Set doGSR to 1 for GSR, 2 for GSS, 0 for neither.
% ss returns the single subject data after adjustment
if nargin<5, doDeriv=false; end

[nn, nt, ns]=size(nxtxs); % # networks, timepoints, subjects
out=nan(size(nxtxs));

if doGSR>0
    gs=squeeze(mean(nxtxs));  % ... global signal (averaged across all ROIs)
else
    gs=[];
end

if ~isempty(HPFcp) && any(~isnan(HPFcp)) && any(HPFcp>0)
    
    if numel(HPFcp)>1
        LPFcp=HPFcp(1);
        HPFcp=HPFcp(2);
    else
        LPFcp=0;
    end
    if isnan(LPFcp)
        LPFcp=0;
    end
    if isnan(HPFcp) || HPFcp==0
        HPFcp=inf;
    end
    % get Discrete Cosine Transform basis set to implement bandpass filter
    TR=1; % TR of this dataset is 1 s
    K   = spm_dctmtx(nt,nt);
    nHP = fix(2*(nt*TR)/HPFcp + 1); % High pass cutoff period specified in s
    nLP = fix(2*(nt*TR)/LPFcp + 1); % Actually don't remove any high frequencies
    K   = K(:,[1:nHP nLP:nt]); % include initial constant term
else
    K=ones(nt,1); % just constant term
end

if doGSR==2 % do global signal subtraction, and turn off global signal regression
    nxtxs=nxtxs-permute(repmat(gs,1,1,nn),[3 1 2]);
    doGSR=0;
end

for s=1:ns
    if doGSR
        X=[gs(:,s), K];
    else
        X=K;
    end
    R  = eye(nt) - X*pinv(X); % residual forming matrix
    out(:,:,s)=(R*nxtxs(:,:,s)')';
end

if doDeriv
    out=gradient(out); % note, 1st output is derivative along 2nd (horizontal) dimension, in this case time.
end

sem=[];
ss=out;

switch MeanOrVar
    case 'mean'
        sem=std(out,[],3)/sqrt(ns);
        out=mean(out,3);
    case 'median'
        out=median(out,3);
    case 'var'
        out=var(out,[],3);
    case 'std'
        out=std(out,[],3);
    case 't'
        out=mean(out,3)./ ( std(out,[],3)/sqrt(ns) );
end

return

function out=cna(nxtxs,ROInames,target,alldata,badsubs)
% confound-nulling average?
[nn, nt, ~]=size(nxtxs);
out=nan(nn,nt);

% if cell array of data per movie is passed as alldata, then concatenate and override x.
% Some subjects have missing MSMall data for some movies, so use 4th input to match up subjects and exclude any with partial data
if nargin>3
    thismovie=cellfun(@(x) isequal(nxtxs,x),alldata);
    assert(sum(thismovie)==1);
    for m=1:length(alldata)
        temp=nan(size(alldata{m},1),size(alldata{m},2),numel(badsubs{1}));
        temp(:,:,~badsubs{m})=alldata{m};
        alldata{m}=temp;
    end
    nxtxs=alldata{thismovie};
    alldata=cat(2,alldata{:});
    drop=squeeze(any(isnan(alldata(1,:,:)),2));
    alldata(:,:,drop)=[];
    nxtxs(:,:,drop)=[];
    txt=sprintf('"%s" confound-nulling average across all movies',target);
else
    alldata=nxtxs;
    txt=sprintf('"%s" confound-nulling average across all movies',target);
end

[nn, nt, ns]=size(alldata);

lsqlinopts = optimoptions('lsqlin','Algorithm','interior-point','display','none');

other=false;
switch target % signal to flatten
    case 'global'
        cs=squeeze(mean(alldata(contains(ROInames,'17'),:,:)));  % ... global signal (averaged across Yeo17 networks, excluding Medial Wall and Core MD)
        w = lsqlin(cs,zeros(nt,1),[],[],ones(1,ns),1,zeros(ns,1),[],[],lsqlinopts); % minimum is global, but not necessarily unique
        
        %%%%% make global look similar to MD!
        %w = lsqlin(cs,squeeze(mean(nxtxs(end,:,:),3)),[],[],ones(1,ns),1,zeros(ns,1),[],[],lsqlinopts); % minimum is global, but not necessarily unique
        %%%%%
        
        fprintf('\n%s (max weight = %.2f)',txt,max(w))
    case 'other'
        other=true; % get cs per network below
        fprintf('\n%s',txt)
    otherwise
        ind=~cellfun(@isempty,regexp(ROInames,target));
        cs=reshape(alldata(ind,:,:),[],ns); % concatenate networks and timepoints
        w = lsqlin(cs,zeros(nt,1),[],[],ones(1,ns),1,zeros(ns,1),[],[],lsqlinopts); % minimum is global, but not necessarily unique
        fprintf('\n%s (max weight = %.2f)',txt,max(w))
end

for n=1:nn
    if other
        ind=setdiff(1:nn,n);
        cs=reshape(nxtxs(ind,:,:),[],ns); % concatenate networks and timepoints
        w = lsqlin(cs,zeros(length(cs),1),[],[],ones(1,ns),1,zeros(ns,1),[],[],lsqlinopts); % minimum is global, but not necessarily unique
    end
    
    out(n,:)=w'*permute(nxtxs(n,:,:),[3 2 1]);
end

return
